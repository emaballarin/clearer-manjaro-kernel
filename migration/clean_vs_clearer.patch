diff --git a/.gitignore b/.gitignore
index 95fa1bb..10f068a 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,2 +1,4 @@
 *tar.xz
+*xz
 src/*
+pkg/*
diff --git a/PKGBUILD b/PKGBUILD
index c3bd898..612771a 100644
--- a/PKGBUILD
+++ b/PKGBUILD
@@ -1,17 +1,25 @@
+# Based on the file created for Manjaro Linux by:
+# Philip Müller (x86_64) <philm@manjaro.org>
+# Jonathon Fernyhough (i686) <jonathon@manjaro.org>
+# Helmut Stult <helmut[at]manjaro[dot]org>
+
 # Based on the file created for Arch Linux by:
 # Tobias Powalowski <tpowa@archlinux.org>
 # Thomas Baechler <thomas@archlinux.org>
 
-# Maintainer: Philip Müller (x86_64) <philm@manjaro.org>
-# Maintainer: Jonathon Fernyhough (i686) <jonathon@manjaro.org>
-# Contributor: Helmut Stult <helmut[at]manjaro[dot]org>
+# Maintainer: Emanuele Ballarin (Clearer Manjaro x86_64) <emanuele@ballarin.cc>
+# And many other contributors (patches, suggestions, development, testing, ...)
+
 
-pkgbase=linux54
-pkgname=('linux54' 'linux54-headers')
-_kernelname=-MANJARO
+pkgbase=linux54-CLEARER
+pkgname=('linux54-CLEARER' 'linux54-CLEARER-headers')
+_kernelname=-CLEARER
 _basekernel=5.4
 _basever=54
 _aufs=20191223
+_wireguard=0.0.20200121
+_ALREADYMERGED=0
+_CLEARERrel=10
 pkgver=5.4.15
 pkgrel=2
 arch=('i686' 'x86_64')
@@ -68,10 +76,78 @@ source=("https://www.kernel.org/pub/linux/kernel/v5.x/linux-${_basekernel}.tar.x
         '0010-bootsplash.patch'
         '0011-bootsplash.patch'
         '0012-bootsplash.patch'
-        '0013-bootsplash.patch')
+        '0013-bootsplash.patch'
+        ## NVIDIA MEMORY COMPACTION PATCH (11/2019)
+        'mmgupta.patch'
+        ## Samsung exFAT
+        "https://raw.githubusercontent.com/sirlucjan/kernel-patches/master/5.4/exfat-patches-v2/0001-exfat-patches.patch"
+        ## Intel Uncore Frequency driver
+        'inteluf_01_edited.patch'
+        'inteluf_02.patch'
+        ## Intel ISST fixes
+        'isst_01.patch'
+        'isst_02.patch'
+        'isst_03.patch'
+        'isst_04.patch'
+        'isst_05.patch'
+        ## POSTFACTUM - EXPOSE KSM INTERFACE
+        "https://raw.githubusercontent.com/sirlucjan/kernel-patches/master/5.4/ksm-patches/0001-ksm-patches.patch"
+        ## CUSTOM PATCHES - PIECES OF XANMOD
+        "https://ballarin.cc/patchwork/pieces_of_xanmod.patch"
+        ## POSTFACTUM - O3 ALWAYS ON
+        "postfactumothree.patch::https://gitlab.com/post-factum/pf-kernel/commit/cf7a8ad26e0bd6ca8afba89f53d2e9dc43ee2598.patch"
+        ## VALVE - MULTIPLE FUTEX
+        "https://raw.githubusercontent.com/sirlucjan/kernel-patches/master/5.4/futex-patches-v2/0001-futex-Add-support-for-multiple-keys-at-the-same-time.patch"
+        ## CUSTOM PATCHES - STUN
+        "https://ballarin.cc/patchwork/00004-manjaro-stun-tickat600.patch"
+        "https://ballarin.cc/patchwork/00005-manjaro-stun-tcpcake.patch"
+        ## BFQ Lucjan
+        "https://raw.githubusercontent.com/sirlucjan/kernel-patches/master/5.4/block-patches-v2-sep/0002-block-Fix-depends-for-BLK_DEV_ZONED.patch"
+        "https://raw.githubusercontent.com/sirlucjan/kernel-patches/master/5.4/bfq-paolo-patches/0001-block-Kconfig.iosched-set-default-value-of-IOSCHED_B.patch"
+        "https://raw.githubusercontent.com/sirlucjan/kernel-patches/master/5.4/bfq-dev-lucjan/5.4-bfq-dev-lucjan-v11-r2K191206.patch"
+        ## Zen Lucjan
+        "https://raw.githubusercontent.com/sirlucjan/kernel-patches/master/5.4/zen-patches-v8-sep/0006-ZEN-intel-pstate-Implement-enable-parameter.patch"
+        ## CLEAR CVEs
+        "https://raw.githubusercontent.com/clearlinux-pkgs/linux/master/CVE-2019-12379.patch"
+        "https://raw.githubusercontent.com/clearlinux-pkgs/linux/master/CVE-2019-19054.patch"
+        ## CLEAR SERIES
+        "https://raw.githubusercontent.com/clearlinux-pkgs/linux/master/0051-rcu-nocb-Fix-dump_tree-hierarchy-print-always-active.patch"
+        "https://raw.githubusercontent.com/clearlinux-pkgs/linux/master/0101-i8042-decrease-debug-message-level-to-info.patch"
+        "https://raw.githubusercontent.com/clearlinux-pkgs/linux/master/0102-Increase-the-ext4-default-commit-age.patch"
+        "https://raw.githubusercontent.com/clearlinux-pkgs/linux/master/0103-silence-rapl.patch"
+        "https://raw.githubusercontent.com/clearlinux-pkgs/linux/master/0104-pci-pme-wakeups.patch"
+        "https://raw.githubusercontent.com/clearlinux-pkgs/linux/master/0105-ksm-wakeups.patch"
+        "https://raw.githubusercontent.com/clearlinux-pkgs/linux/master/0106-intel_idle-tweak-cpuidle-cstates.patch"
+        "https://raw.githubusercontent.com/clearlinux-pkgs/linux/master/0108-smpboot-reuse-timer-calibration.patch"
+        "https://raw.githubusercontent.com/clearlinux-pkgs/linux/master/0109-raid6-add-Kconfig-option-to-skip-raid6-benchmarking.patch"
+        "https://raw.githubusercontent.com/clearlinux-pkgs/linux/master/0110-Initialize-ata-before-graphics.patch"
+        "https://raw.githubusercontent.com/clearlinux-pkgs/linux/master/0111-give-rdrand-some-credit.patch"
+        "https://raw.githubusercontent.com/clearlinux-pkgs/linux/master/0112-ipv4-tcp-allow-the-memory-tuning-for-tcp-to-go-a-lit.patch"
+        "https://raw.githubusercontent.com/clearlinux-pkgs/linux/master/0113-kernel-time-reduce-ntp-wakeups.patch"
+        "https://raw.githubusercontent.com/clearlinux-pkgs/linux/master/0114-init-wait-for-partition-and-retry-scan.patch"
+        "https://raw.githubusercontent.com/clearlinux-pkgs/linux/master/0118-Migrate-some-systemd-defaults-to-the-kernel-defaults.patch"
+        "https://raw.githubusercontent.com/clearlinux-pkgs/linux/master/0119-xattr-allow-setting-user.-attributes-on-symlinks-by-.patch"
+        "https://raw.githubusercontent.com/clearlinux-pkgs/linux/master/0120-add-scheduler-turbo3-patch.patch"
+        "https://raw.githubusercontent.com/clearlinux-pkgs/linux/master/0121-use-lfence-instead-of-rep-and-nop.patch"
+        "https://raw.githubusercontent.com/clearlinux-pkgs/linux/master/0122-do-accept-in-LIFO-order-for-cache-efficiency.patch"
+        "https://raw.githubusercontent.com/clearlinux-pkgs/linux/master/0124-locking-rwsem-spin-faster.patch"
+        "https://raw.githubusercontent.com/clearlinux-pkgs/linux/master/0125-ata-libahci-ignore-staggered-spin-up.patch"
+        "https://raw.githubusercontent.com/clearlinux-pkgs/linux/master/0127-x86-microcode-Force-update-a-uCode-even-if-the-rev-i.patch"
+        "https://raw.githubusercontent.com/clearlinux-pkgs/linux/master/0128-x86-microcode-echo-2-reload-to-force-load-ucode.patch"
+        "https://raw.githubusercontent.com/clearlinux-pkgs/linux/master/0129-fix-bug-in-ucode-force-reload-revision-check.patch"
+        "https://raw.githubusercontent.com/clearlinux-pkgs/linux/master/0130-add-workaround-for-binutils-optimization.patch"
+        "https://raw.githubusercontent.com/clearlinux-pkgs/linux/master/0131-nvme-workaround.patch"
+        ## SCHEDULER - BMQ
+        "https://gitlab.com/alfredchen/bmq/raw/master/5.4/bmq_v5.4-r2.patch"
+        ## GRAYSKY2 GCC OPTIMIZATIONS
+        "grayskygcc.patch::https://raw.githubusercontent.com/graysky2/kernel_gcc_patch/master/enable_additional_cpu_optimizations_for_gcc_v9.1%2B_kernel_v4.13%2B.patch"
+        ## Wireguard - Kernel autopatcher
+        "https://git.zx2c4.com/wireguard-linux-compat/snapshot/wireguard-linux-compat-${_wireguard}.tar.xz")
+
 sha256sums=('bf338980b1670bca287f9994b7441c2361907635879169c64ae78364efc5f491'
             'ff95ac79de6d23f5e87184d67f23ee0613707ed84b2fbe4280182ada2945dfda'
-            '8e6dc31f5b76de3c398eef312b5c3423039b4bd1b3e7776542c409fd26d60a3c'
+            # x86_64 config -->
+            'SKIP'
             'bfe52746bfc04114627b6f1e0dd94bc05dd94abe8f6dbee770f78d6116e315e8'
             'b44d81446d8b53d5637287c30ae3eb64cae0078c3fbc45fcf1081dd6699818b5'
             'eb2de93799728d81b288e4d705c2194ed29da5b1316fab2ba01d1fcf6125d740'
@@ -114,18 +190,149 @@ sha256sums=('bf338980b1670bca287f9994b7441c2361907635879169c64ae78364efc5f491'
             'e9f22cbb542591087d2d66dc6dc912b1434330ba3cd13d2df741d869a2c31e89'
             '27471eee564ca3149dd271b0817719b5565a9594dc4d884fe3dc51a5f03832bc'
             '60e295601e4fb33d9bf65f198c54c7eb07c0d1e91e2ad1e0dd6cd6e142cb266d'
-            '035ea4b2a7621054f4560471f45336b981538a40172d8f17285910d4e0e0b3ef')
+            '035ea4b2a7621054f4560471f45336b981538a40172d8f17285910d4e0e0b3ef'
+            ##
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP'
+            'SKIP')
 prepare() {
   cd "${srcdir}/linux-${_basekernel}"
 
+  ### START OF PATCHES ###
+  echo " "
+  echo "PATCH: Kernel upstream"
   # add upstream patch
   patch -p1 -i "${srcdir}/patch-${pkgver}"
+  echo " "
 
   # add latest fixes from stable queue, if needed
   # http://git.kernel.org/?p=linux/kernel/git/stable/stable-queue.git
   # enable only if you have "gen-stable-queue-patch.sh" executed before
   #patch -Np1 -i "${srcdir}/prepatch-${_basekernel}.patch"
 
+  ## CLEARER MANJARO: New exFAT drivers by Samsung
+  echo " "
+  echo "PATCH: Samsung exFAT drivers"
+  patch -Np1 -i ../0001-exfat-patches.patch
+  echo " "
+
+  ## Intel ISST fixes
+#  echo " "
+#  echo "PATCH: Intel ISST fixes"
+#  patch -Np1 -i ../isst_01.patch
+#  patch -Np1 -i ../isst_02.patch
+#  patch -Np1 -i ../isst_03.patch
+#  patch -Np1 -i ../isst_04.patch
+#  patch -Np1 -i ../isst_05.patch
+#  echo " "
+
+  ## Zen Lucjan
+  echo " "
+  echo "PATCH: Explicit PSTATE parameter"
+  patch -Np1 -i ../0006-ZEN-intel-pstate-Implement-enable-parameter.patch
+  echo " "
+
+  ## Intel Uncore Frequency driver
+  echo " "
+  echo "PATCH: Intel UnCore frequency driver"
+  patch -Np1 -i ../inteluf_01_edited.patch
+  patch -Np1 -i ../inteluf_02.patch
+  echo " "
+
+  ## CLEARER MANJARO: PIECES OF XANMOD
+  echo " "
+  echo "PATCH: Pieces of XanMod"
+  patch -Np1 -i ../pieces_of_xanmod.patch
+  echo " "
+
+  ## CLEARER MANJARO: STUN PATCHES
+  echo " "
+  echo "PATCH: STUN patches"
+  patch -Np1 -i ../00004-manjaro-stun-tickat600.patch
+  patch -Np1 -i ../00005-manjaro-stun-tcpcake.patch
+  echo " "
+
+  ## CLEARER MANJARO - MMGUPTA MEMORY MERGING
+  echo " "
+  echo "PATCH: Proactive memory compaction"
+  patch -Np1 -i ../mmgupta.patch
+  echo " "
+
+  ## CLEARER MANJARO - KSM (NATALENKO)
+  echo " "
+  echo "PATCH: PostFactum KSM"
+  patch -Np1 -i ../0001-ksm-patches.patch
+  echo " "
+
+  ## CLEARER MANJARO: POSTFACTUM O3 ALWAYS ON
+  echo " "
+  echo "PATCH: Always-on -O3"
+  patch -Np1 -i ../postfactumothree.patch
+  echo " "
+
+  ## CLEARER MANJARO: FUTEX WAIT MULTIPLE (VALVE)
+  echo " "
+  echo "PATCH: Multiple FutEx"
+  patch -Np1 -i ../0001-futex-Add-support-for-multiple-keys-at-the-same-time.patch
+  echo " "
+
+  ## CLEARER MANJARO: BFQ PATCHES
+  echo " "
+  echo "PATCH: BFQ development branch"
+  patch -Np1 -i ../0002-block-Fix-depends-for-BLK_DEV_ZONED.patch
+  patch -Np1 -i ../0001-block-Kconfig.iosched-set-default-value-of-IOSCHED_B.patch
+  patch -Np1 -i ../5.4-bfq-dev-lucjan-v11-r2K191206.patch
+  echo " "
+
+  echo " "
+  echo "PATCH: Manjaro defaults"
   # disable USER_NS for non-root users by default
   patch -Np1 -i ../0001-ZEN-Add-sysctl-and-CONFIG-to-disallow-unprivileged-CLONE_NEWUSER.patch
 
@@ -192,6 +399,72 @@ prepare() {
   patch -Np1 -i "${srcdir}/aufs5-standalone.patch"
   patch -Np1 -i "${srcdir}/tmpfs-idr.patch"
   patch -Np1 -i "${srcdir}/vfs-ino.patch"
+  echo " "
+
+  ## CLEARER MANJARO: CLEAR CVE FIXES
+  echo " "
+  echo "PATCH: CVE fixes from Intel"
+  patch -Np1 -i ../CVE-2019-12379.patch
+  patch -Np1 -i ../CVE-2019-19054.patch
+  echo " "
+
+  ## CLEARER MANJARO: CLEAR SERIES PATCHES
+  echo " "
+  echo "PATCH: Clear Linux patches"
+  patch -Np1 -i ../0051-rcu-nocb-Fix-dump_tree-hierarchy-print-always-active.patch
+  patch -Np1 -i ../0101-i8042-decrease-debug-message-level-to-info.patch
+  patch -Np1 -i ../0102-Increase-the-ext4-default-commit-age.patch
+  patch -Np1 -i ../0103-silence-rapl.patch
+  patch -Np1 -i ../0104-pci-pme-wakeups.patch
+  patch -Np1 -i ../0105-ksm-wakeups.patch
+  patch -Np1 -i ../0106-intel_idle-tweak-cpuidle-cstates.patch
+  patch -Np1 -i ../0108-smpboot-reuse-timer-calibration.patch
+  patch -Np1 -i ../0109-raid6-add-Kconfig-option-to-skip-raid6-benchmarking.patch
+  patch -Np1 -i ../0110-Initialize-ata-before-graphics.patch
+  patch -Np1 -i ../0111-give-rdrand-some-credit.patch
+  patch -Np1 -i ../0112-ipv4-tcp-allow-the-memory-tuning-for-tcp-to-go-a-lit.patch
+  patch -Np1 -i ../0113-kernel-time-reduce-ntp-wakeups.patch
+  patch -Np1 -i ../0114-init-wait-for-partition-and-retry-scan.patch
+  patch -Np1 -i ../0118-Migrate-some-systemd-defaults-to-the-kernel-defaults.patch
+  patch -Np1 -i ../0119-xattr-allow-setting-user.-attributes-on-symlinks-by-.patch
+  #patch -Np1 -i ../0120-add-scheduler-turbo3-patch.patch # Incompatible
+  patch -Np1 -i ../0121-use-lfence-instead-of-rep-and-nop.patch
+  patch -Np1 -i ../0122-do-accept-in-LIFO-order-for-cache-efficiency.patch
+  patch -Np1 -i ../0124-locking-rwsem-spin-faster.patch
+  patch -Np1 -i ../0125-ata-libahci-ignore-staggered-spin-up.patch
+  patch -Np1 -i ../0127-x86-microcode-Force-update-a-uCode-even-if-the-rev-i.patch
+  patch -Np1 -i ../0128-x86-microcode-echo-2-reload-to-force-load-ucode.patch
+  patch -Np1 -i ../0129-fix-bug-in-ucode-force-reload-revision-check.patch
+  #patch -Np1 -i ../0130-add-workaround-for-binutils-optimization.patch
+  patch -Np1 -i ../0131-nvme-workaround.patch
+  echo " "
+
+  # WireGuard AutoPatcher
+  echo " "
+  echo "PATCH: Wireguard"
+  _prewg_curdir="$(pwd)"
+  cd "${srcdir}/wireguard-linux-compat-${_wireguard}/kernel-tree-scripts/"
+  _wg_ker_calldir="$(pwd)"
+  cd "${srcdir}/linux-${_basekernel}/"
+  "$_wg_ker_calldir/create-patch.sh" > ./wgpatch.patch
+  patch -p1 -i ./wgpatch.patch
+  rm ./wgpatch.patch
+  cd "$_prewg_curdir"
+  echo " "
+
+  ## CLEARER MANJARO: BMQ SCHEDULER
+  echo " "
+  echo "PATCH: BMQ scheduler"
+  patch -Np1 -i ../bmq_v5.4-r2.patch
+  echo " "
+
+  ## CLEARER MANJARO: GRAYSKY2 GCC OPTIMIZATIONS
+  echo " "
+  echo "PATCH: GraySky"
+  patch -Np1 -i ../grayskygcc.patch
+  echo " "
+
+  ### END OF PATCHES ###
 
   if [ "${CARCH}" = "x86_64" ]; then
     cat "${srcdir}/config.x86_64" > ./.config
@@ -216,7 +489,7 @@ prepare() {
   sed -i '2iexit 0' scripts/depmod.sh
 
   # get kernel version
-  make prepare
+  make prepare -j12
 
   # load configuration
   # Configure the kernel. Replace the line below with one of your choice.
@@ -227,31 +500,32 @@ prepare() {
   # ... or manually edit .config
 
   # rewrite configuration
-  yes "" | make config >/dev/null
+  yes "" | make config -j12 >/dev/null
 }
 
 build() {
   cd "${srcdir}/linux-${_basekernel}"
 
   # build!
-  make ${MAKEFLAGS} LOCALVERSION= bzImage modules
+  make ${MAKEFLAGS} -j12 LOCALVERSION= bzImage modules
 }
 
-package_linux54() {
+package_linux54-CLEARER() {
   pkgdesc="The ${pkgbase/linux/Linux} kernel and modules"
   depends=('coreutils' 'linux-firmware' 'kmod' 'mkinitcpio>=27')
-  optdepends=('crda: to set the correct wireless channels of your country')
-  provides=("linux=${pkgver}")
+  optdepends=('crda: to set the correct wireless channels of your country' 'wireguard-tools: to use the Wireguard module included')
+  provides=("linux54" "linux=${pkgver}" "WIREGUARD-MODULE")
+  conflicts=("linux54")
 
   cd "${srcdir}/linux-${_basekernel}"
 
   KARCH=x86
 
   # get kernel version
-  _kernver="$(make LOCALVERSION= kernelrelease)"
+  _kernver="$(make -j12 LOCALVERSION= kernelrelease)"
 
   mkdir -p "${pkgdir}"/{boot,usr/lib/modules}
-  make LOCALVERSION= INSTALL_MOD_PATH="${pkgdir}/usr" modules_install
+  make -j12 LOCALVERSION= INSTALL_MOD_PATH="${pkgdir}/usr" modules_install
 
   # systemd expects to find the kernel here to allow hibernation
   # https://github.com/systemd/systemd/commit/edda44605f06a41fb86b7ab8128dcf99161d2344
@@ -263,13 +537,13 @@ package_linux54() {
 
   # add kernel version
   if [ "${CARCH}" = "x86_64" ]; then
-     echo "${pkgver}-${pkgrel}-MANJARO x64" > "${pkgdir}/boot/${pkgbase}-${CARCH}.kver"
+     echo "${pkgver}-${pkgrel}-CLEARER x64" > "${pkgdir}/boot/${pkgbase}-${CARCH}.kver"
   else
-     echo "${pkgver}-${pkgrel}-MANJARO x32" > "${pkgdir}/boot/${pkgbase}-${CARCH}.kver"
+     echo "${pkgver}-${pkgrel}-CLEARER x32" > "${pkgdir}/boot/${pkgbase}-${CARCH}.kver"
   fi
 
   # make room for external modules
-  local _extramodules="extramodules-${_basekernel}${_kernelname:--MANJARO}"
+  local _extramodules="extramodules-${_basekernel}${_kernelname:--CLEARER}"
   ln -s "../${_extramodules}" "${pkgdir}/usr/lib/modules/${_kernver}/extramodules"
 
   # add real version for building modules and running depmod from hook
@@ -286,9 +560,10 @@ package_linux54() {
   install -Dt "${pkgdir}/usr/lib/modules/${_kernver}/build" -m644 vmlinux
 }
 
-package_linux54-headers() {
+package_linux54-CLEARER-headers() {
   pkgdesc="Header files and scripts for building modules for ${pkgbase/linux/Linux} kernel"
-  provides=("linux-headers=$pkgver")
+  provides=("linux54-headers" "linux-headers=$pkgver")
+  conflicts=("linux54-headers")
 
   cd "${srcdir}/linux-${_basekernel}"
   local _builddir="${pkgdir}/usr/lib/modules/${_kernver}/build"
diff --git a/config.x86_64 b/config.x86_64
index c780729..ce42313 100644
--- a/config.x86_64
+++ b/config.x86_64
@@ -13,6 +13,7 @@ CONFIG_CC_CAN_LINK=y
 CONFIG_CC_HAS_ASM_GOTO=y
 CONFIG_CC_HAS_ASM_INLINE=y
 CONFIG_CC_HAS_WARN_MAYBE_UNINITIALIZED=y
+CONFIG_CC_DISABLE_WARN_MAYBE_UNINITIALIZED=y
 CONFIG_IRQ_WORK=y
 CONFIG_BUILDTIME_EXTABLE_SORT=y
 CONFIG_THREAD_INFO_IN_TASK=y
@@ -20,10 +21,12 @@ CONFIG_THREAD_INFO_IN_TASK=y
 #
 # General setup
 #
+CONFIG_SCHED_BMQ=y
+CONFIG_SCHED_TIMESLICE=2
 CONFIG_INIT_ENV_ARG_LIMIT=32
 # CONFIG_COMPILE_TEST is not set
 # CONFIG_HEADER_TEST is not set
-CONFIG_LOCALVERSION="-MANJARO"
+CONFIG_LOCALVERSION="-CLEARER"
 # CONFIG_LOCALVERSION_AUTO is not set
 CONFIG_BUILD_SALT=""
 CONFIG_HAVE_KERNEL_GZIP=y
@@ -35,10 +38,10 @@ CONFIG_HAVE_KERNEL_LZ4=y
 # CONFIG_KERNEL_GZIP is not set
 # CONFIG_KERNEL_BZIP2 is not set
 # CONFIG_KERNEL_LZMA is not set
-CONFIG_KERNEL_XZ=y
+# CONFIG_KERNEL_XZ is not set
 # CONFIG_KERNEL_LZO is not set
-# CONFIG_KERNEL_LZ4 is not set
-CONFIG_DEFAULT_HOSTNAME="manjaro"
+CONFIG_KERNEL_LZ4=y
+CONFIG_DEFAULT_HOSTNAME="CLEARER"
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 CONFIG_SYSVIPC_SYSCTL=y
@@ -132,7 +135,7 @@ CONFIG_RCU_FANOUT=64
 CONFIG_RCU_FANOUT_LEAF=16
 CONFIG_RCU_FAST_NO_HZ=y
 CONFIG_RCU_BOOST=y
-CONFIG_RCU_BOOST_DELAY=500
+CONFIG_RCU_BOOST_DELAY=0
 # CONFIG_RCU_NOCB_CPU is not set
 # end of RCU Subsystem
 
@@ -202,6 +205,7 @@ CONFIG_RD_XZ=y
 CONFIG_RD_LZO=y
 CONFIG_RD_LZ4=y
 CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE=y
+CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE_O3=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
 CONFIG_SYSCTL=y
 CONFIG_HAVE_UID16=y
@@ -255,7 +259,7 @@ CONFIG_PERF_EVENTS=y
 # end of Kernel Performance Events And Counters
 
 CONFIG_VM_EVENT_COUNTERS=y
-CONFIG_SLUB_DEBUG=y
+# CONFIG_SLUB_DEBUG is not set
 # CONFIG_SLUB_MEMCG_SYSFS_ON is not set
 # CONFIG_COMPAT_BRK is not set
 # CONFIG_SLAB is not set
@@ -307,6 +311,7 @@ CONFIG_ARCH_SUPPORTS_UPROBES=y
 CONFIG_FIX_EARLYCON_MEM=y
 CONFIG_DYNAMIC_PHYSICAL_MASK=y
 CONFIG_PGTABLE_LEVELS=5
+CONFIG_HAVE_CC_STACKPROTECTOR=y
 CONFIG_CC_HAS_SANE_STACKPROTECTOR=y
 
 #
@@ -355,7 +360,34 @@ CONFIG_ACRN_GUEST=y
 # CONFIG_MPSC is not set
 # CONFIG_MCORE2 is not set
 # CONFIG_MATOM is not set
-CONFIG_GENERIC_CPU=y
+# CONFIG_MK8SSE3 is not set
+# CONFIG_MK10 is not set
+# CONFIG_MBARCELONA is not set
+# CONFIG_MBOBCAT is not set
+# CONFIG_MJAGUAR is not set
+# CONFIG_MBULLDOZER is not set
+# CONFIG_MPILEDRIVER is not set
+# CONFIG_MSTEAMROLLER is not set
+# CONFIG_MEXCAVATOR is not set
+# CONFIG_MZEN is not set
+# CONFIG_MZEN2 is not set
+# CONFIG_MNEHALEM is not set
+# CONFIG_MWESTMERE is not set
+# CONFIG_MSILVERMONT is not set
+# CONFIG_MGOLDMONT is not set
+# CONFIG_MGOLDMONTPLUS is not set
+# CONFIG_MSANDYBRIDGE is not set
+# CONFIG_MIVYBRIDGE is not set
+# CONFIG_MHASWELL is not set
+# CONFIG_MBROADWELL is not set
+# CONFIG_MSKYLAKE is not set
+# CONFIG_MSKYLAKEX is not set
+# CONFIG_MCANNONLAKE is not set
+# CONFIG_MICELAKE is not set
+# CONFIG_MCASCADELAKE is not set
+# CONFIG_GENERIC_CPU is not set
+CONFIG_MNATIVE=y
+CONFIG_X86_P6_NOP=y
 CONFIG_X86_INTERNODE_CACHE_SHIFT=6
 CONFIG_X86_L1_CACHE_SHIFT=6
 CONFIG_X86_TSC=y
@@ -380,6 +412,7 @@ CONFIG_NR_CPUS_RANGE_BEGIN=2
 CONFIG_NR_CPUS_RANGE_END=512
 CONFIG_NR_CPUS_DEFAULT=64
 CONFIG_NR_CPUS=320
+CONFIG_SMT_NICE=y
 CONFIG_SCHED_SMT=y
 CONFIG_SCHED_MC=y
 CONFIG_SCHED_MC_PRIO=y
@@ -401,6 +434,7 @@ CONFIG_PERF_EVENTS_INTEL_UNCORE=m
 CONFIG_PERF_EVENTS_INTEL_RAPL=m
 CONFIG_PERF_EVENTS_INTEL_CSTATE=m
 CONFIG_PERF_EVENTS_AMD_POWER=m
+CONFIG_INTEL_UNCORE_FREQ_CONTROL=m
 # end of Performance monitoring
 
 CONFIG_X86_16BIT=y
@@ -455,9 +489,10 @@ CONFIG_EFI_MIXED=y
 CONFIG_SECCOMP=y
 # CONFIG_HZ_100 is not set
 # CONFIG_HZ_250 is not set
-CONFIG_HZ_300=y
+# CONFIG_HZ_300 is not set
 # CONFIG_HZ_1000 is not set
-CONFIG_HZ=300
+CONFIG_HZ_600=y
+CONFIG_HZ=600
 CONFIG_SCHED_HRTICK=y
 CONFIG_KEXEC=y
 CONFIG_KEXEC_FILE=y
@@ -1078,6 +1113,8 @@ CONFIG_SMC_DIAG=m
 CONFIG_XDP_SOCKETS=y
 CONFIG_XDP_SOCKETS_DIAG=y
 CONFIG_INET=y
+CONFIG_WIREGUARD=m
+# CONFIG_WIREGUARD_DEBUG is not set
 CONFIG_IP_MULTICAST=y
 CONFIG_IP_ADVANCED_ROUTER=y
 # CONFIG_IP_FIB_TRIE_STATS is not set
@@ -1112,9 +1149,12 @@ CONFIG_INET_TCP_DIAG=m
 CONFIG_INET_UDP_DIAG=m
 CONFIG_INET_RAW_DIAG=m
 CONFIG_INET_DIAG_DESTROY=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=m
+CONFIG_INET_XFRM_MODE_TUNNEL=m
+CONFIG_INET_XFRM_MODE_BEET=m
 CONFIG_TCP_CONG_ADVANCED=y
 CONFIG_TCP_CONG_BIC=m
-CONFIG_TCP_CONG_CUBIC=y
+CONFIG_TCP_CONG_CUBIC=m
 CONFIG_TCP_CONG_WESTWOOD=m
 CONFIG_TCP_CONG_HTCP=m
 CONFIG_TCP_CONG_HSTCP=m
@@ -1128,10 +1168,10 @@ CONFIG_TCP_CONG_YEAH=m
 CONFIG_TCP_CONG_ILLINOIS=m
 CONFIG_TCP_CONG_DCTCP=m
 CONFIG_TCP_CONG_CDG=m
-CONFIG_TCP_CONG_BBR=m
-CONFIG_DEFAULT_CUBIC=y
+CONFIG_TCP_CONG_BBR=y
+CONFIG_DEFAULT_BBR=y
 # CONFIG_DEFAULT_RENO is not set
-CONFIG_DEFAULT_TCP_CONG="cubic"
+CONFIG_DEFAULT_TCP_CONG="bbr"
 CONFIG_TCP_MD5SIG=y
 CONFIG_IPV6=y
 CONFIG_IPV6_ROUTER_PREF=y
@@ -1145,6 +1185,10 @@ CONFIG_IPV6_MIP6=m
 CONFIG_IPV6_ILA=m
 CONFIG_INET6_XFRM_TUNNEL=m
 CONFIG_INET6_TUNNEL=m
+CONFIG_INET6_XFRM_MODE_TRANSPORT=m
+CONFIG_INET6_XFRM_MODE_TUNNEL=m
+CONFIG_INET6_XFRM_MODE_BEET=m
+CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION=m
 CONFIG_IPV6_VTI=m
 CONFIG_IPV6_SIT=m
 CONFIG_IPV6_SIT_6RD=y
@@ -1429,6 +1473,13 @@ CONFIG_NF_DUP_IPV4=m
 CONFIG_NF_LOG_ARP=m
 CONFIG_NF_LOG_IPV4=m
 CONFIG_NF_REJECT_IPV4=m
+CONFIG_NFT_CHAIN_ROUTE_IPV4=m
+CONFIG_NF_NAT_IPV4=m
+CONFIG_NF_NAT_MASQUERADE_IPV4=y
+CONFIG_NFT_CHAIN_NAT_IPV4=m
+CONFIG_NFT_MASQ_IPV4=m
+CONFIG_NFT_REDIR_IPV4=m
+CONFIG_NF_NAT_PROTO_GRE=m
 CONFIG_NF_NAT_SNMP_BASIC=m
 CONFIG_NF_NAT_PPTP=m
 CONFIG_NF_NAT_H323=m
@@ -1453,6 +1504,7 @@ CONFIG_IP_NF_SECURITY=m
 CONFIG_IP_NF_ARPTABLES=m
 CONFIG_IP_NF_ARPFILTER=m
 CONFIG_IP_NF_ARP_MANGLE=m
+CONFIG_NF_NAT_NEEDED=y
 # end of IP: Netfilter Configuration
 
 #
@@ -1468,6 +1520,12 @@ CONFIG_NF_FLOW_TABLE_IPV6=m
 CONFIG_NF_DUP_IPV6=m
 CONFIG_NF_REJECT_IPV6=m
 CONFIG_NF_LOG_IPV6=m
+CONFIG_NFT_CHAIN_ROUTE_IPV6=m
+CONFIG_NFT_CHAIN_NAT_IPV6=m
+CONFIG_NFT_MASQ_IPV6=m
+CONFIG_NFT_REDIR_IPV6=m
+CONFIG_NF_NAT_IPV6=m
+CONFIG_NF_NAT_MASQUERADE_IPV6=y
 CONFIG_IP6_NF_IPTABLES=m
 CONFIG_IP6_NF_MATCH_AH=m
 CONFIG_IP6_NF_MATCH_EUI64=m
@@ -1655,10 +1713,11 @@ CONFIG_NET_SCH_PLUG=m
 CONFIG_NET_SCH_DEFAULT=y
 # CONFIG_DEFAULT_FQ is not set
 # CONFIG_DEFAULT_CODEL is not set
-CONFIG_DEFAULT_FQ_CODEL=y
+# CONFIG_DEFAULT_FQ_CODEL is not set
+CONFIG_DEFAULT_CAKE=y
 # CONFIG_DEFAULT_SFQ is not set
 # CONFIG_DEFAULT_PFIFO_FAST is not set
-CONFIG_DEFAULT_NET_SCH="fq_codel"
+CONFIG_DEFAULT_NET_SCH="cake"
 
 #
 # Classification
@@ -1754,6 +1813,7 @@ CONFIG_CGROUP_NET_PRIO=y
 CONFIG_CGROUP_NET_CLASSID=y
 CONFIG_NET_RX_BUSY_POLL=y
 CONFIG_BQL=y
+CONFIG_HAVE_BPF_JIT=y
 CONFIG_BPF_JIT=y
 CONFIG_BPF_STREAM_PARSER=y
 CONFIG_NET_FLOW_LIMIT=y
@@ -2584,6 +2644,7 @@ CONFIG_RAID_ATTRS=m
 CONFIG_SCSI=m
 CONFIG_SCSI_DMA=y
 CONFIG_SCSI_NETLINK=y
+CONFIG_SCSI_MQ_DEFAULT=y
 CONFIG_SCSI_PROC_FS=y
 
 #
@@ -4201,7 +4262,7 @@ CONFIG_TRACE_ROUTER=m
 CONFIG_TRACE_SINK=m
 CONFIG_NULL_TTY=m
 CONFIG_LDISC_AUTOLOAD=y
-CONFIG_DEVMEM=y
+# CONFIG_DEVMEM is not set
 # CONFIG_DEVKMEM is not set
 
 #
@@ -6552,6 +6613,7 @@ CONFIG_FB_SIMPLE=y
 #
 # Backlight & LCD device support
 #
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
 CONFIG_LCD_CLASS_DEVICE=m
 CONFIG_LCD_L4F00242T03=m
 CONFIG_LCD_LMS283GF05=m
@@ -8497,12 +8559,12 @@ CONFIG_UWB_HWA=m
 CONFIG_UWB_WHCI=m
 CONFIG_UWB_I1480U=m
 CONFIG_EXFAT_FS=m
-CONFIG_EXFAT_DONT_MOUNT_VFAT=y
-CONFIG_EXFAT_DISCARD=y
+# CONFIG_EXFAT_DONT_MOUNT_VFAT=y
+# CONFIG_EXFAT_DISCARD=y
 # CONFIG_EXFAT_DELAYED_SYNC is not set
 # CONFIG_EXFAT_KERNEL_DEBUG is not set
 # CONFIG_EXFAT_DEBUG_MSG is not set
-CONFIG_EXFAT_DEFAULT_CODEPAGE=437
+# CONFIG_EXFAT_DEFAULT_CODEPAGE=437
 CONFIG_EXFAT_DEFAULT_IOCHARSET="utf8"
 CONFIG_QLGE=m
 CONFIG_X86_PLATFORM_DEVICES=y
@@ -9627,6 +9689,9 @@ CONFIG_FAT_DEFAULT_UTF8=y
 CONFIG_NTFS_FS=m
 # CONFIG_NTFS_DEBUG is not set
 CONFIG_NTFS_RW=y
+CONFIG_EXFAT_FS_SAMSUNG=n
+CONFIG_EXFAT=y
+CONFIG_EXFAT_FS_DEFAULT_IOCHARSET="utf-8"
 # end of DOS/FAT/NT Filesystems
 
 #
@@ -9891,7 +9956,7 @@ CONFIG_SECURITY_PATH=y
 CONFIG_LSM_MMAP_MIN_ADDR=65536
 CONFIG_HAVE_HARDENED_USERCOPY_ALLOCATOR=y
 CONFIG_HARDENED_USERCOPY=y
-CONFIG_HARDENED_USERCOPY_FALLBACK=y
+# CONFIG_HARDENED_USERCOPY_FALLBACK is not set
 # CONFIG_HARDENED_USERCOPY_PAGESPAN is not set
 CONFIG_FORTIFY_SOURCE=y
 # CONFIG_STATIC_USERMODEHELPER is not set
@@ -10197,10 +10262,20 @@ CONFIG_SYSTEM_BLACKLIST_HASH_LIST=""
 
 CONFIG_BINARY_PRINTF=y
 
+
 #
-# Library routines
+# RAID 6
 #
 CONFIG_RAID6_PQ=m
+CONFIG_RAID6_FORCE_ALGO=y
+# CONFIG_RAID6_FORCE_INT is not set
+# CONFIG_RAID6_FORCE_SSSE3 is not set
+CONFIG_RAID6_FORCE_AVX2=y
+# end of RAID 6
+
+#
+# Library routines
+#
 CONFIG_RAID6_PQ_BENCHMARK=y
 CONFIG_PACKING=y
 CONFIG_BITREVERSE=y
diff --git a/install-everything-standalone.sh b/install-everything-standalone.sh
new file mode 100755
index 0000000..70373c7
--- /dev/null
+++ b/install-everything-standalone.sh
@@ -0,0 +1,143 @@
+#!/bin/zsh
+
+##
+## Install (0) the 'Clearer Manjaro' Kernel and the related (1) nvidia,
+## (2) acpi_call, (3) virtualbox_host, (4) SPL/ZFS, kernel extramodules.
+## Note that this script is meant to REPLACE currently-installed "linux54"
+## packages.
+##
+## (C) 2019-* Emanuele Ballarin
+## MIT License
+##
+
+##################
+## Get packages ##
+##################
+
+# Export variables
+export CLEARERMANJARO_TMPDIR="$(pwd)/TMPDIR"
+export CLEARERMANJARO_PKGS="$(pwd)/PKGS"
+
+# Prepare build/install structure
+mkdir -p "$CLEARERMANJARO_TMPDIR"
+mkdir -p "$CLEARERMANJARO_PKGS"
+
+# Clean-up (eventual) previous build
+cd "$CLEARERMANJARO_TMPDIR"
+rm -R -f ./*
+
+# Clone relevant git repositories
+cd "$CLEARERMANJARO_TMPDIR"
+
+git clone --recursive https://github.com/emaballarin/clearer-manjaro-kernel.git
+git clone --recursive https://github.com/emaballarin/clearer-manjaro-kernel-nvidia.git
+git clone --recursive https://gitlab.manjaro.org/packages/extra/linux54-extramodules/acpi_call.git
+git clone --recursive https://gitlab.manjaro.org/packages/extra/linux54-extramodules/virtualbox-modules.git
+git clone --recursive https://gitlab.manjaro.org/packages/extra/linux54-extramodules/spl_zfs.git
+
+###############################
+## Auto-reconfigure packages ##
+###############################
+
+# acpi_call
+cd "$CLEARERMANJARO_TMPDIR/acpi_call"
+mv ./acpi_call.install ./acpi_call-CLEARER.install
+sed -i "s/_linuxprefix=.*/_linuxprefix=linux54-CLEARER/g" ./PKGBUILD
+sed -i "s/_extramodules=.*/_extramodules=extramodules-5.4-CLEARER/g" ./PKGBUILD
+sed -i "s/install=\$_pkgname\.install.*/install=acpi_call-CLEARER\.install/g" ./PKGBUILD
+sed -i "s/acpi_call\.install\"/acpi_call-CLEARER\.install\"/g" ./PKGBUILD
+
+
+# SPL/ZFS
+cd "$CLEARERMANJARO_TMPDIR/spl_zfs"
+mv ./install ./spl_zfs-CLEARER.install
+sed -i "s/_linuxprefix=.*/_linuxprefix=linux54-CLEARER/g" ./PKGBUILD
+sed -i "s/_extramodules=.*/_extramodules=extramodules-5.4-CLEARER/g" ./PKGBUILD
+sed -i "s/install=install.*/install=spl_zfs-CLEARER\.install/g" ./PKGBUILD
+sed -i "s/install\"/spl_zfs-CLEARER\.install\"/g" ./PKGBUILD
+#sed -i "s/package_linux54-spl/package_linux54-clearer-spl/g" ./PKGBUILD
+sed -i "s/package_linux54-zfs/package_linux54-CLEARER-zfs/g" ./PKGBUILD
+
+# virtualbox-modules
+cd "$CLEARERMANJARO_TMPDIR/virtualbox-modules"
+mv ./virtualbox-host-modules.install ./virtualbox-host-modules-CLEARER.install
+mv ./virtualbox-guest-modules.install ./virtualbox-guest-modules-CLEARER.install
+sed -i "s/_linuxprefix=.*/_linuxprefix=linux54-CLEARER/g" ./PKGBUILD
+sed -i "s/_extramodules=.*/_extramodules=extramodules-5.4-CLEARER/g" ./PKGBUILD
+sed -i "s/install=virtualbox-host-modules\.install.*/install=virtualbox-host-modules-CLEARER\.install/g" ./PKGBUILD
+sed -i "s/install=virtualbox-guest-modules\.install.*/install=virtualbox-guest-modules-CLEARER\.install/g" ./PKGBUILD
+sed -i "s/virtualbox-host-modules\.install\"/virtualbox-host-modules-CLEARER\.install\"/g" ./PKGBUILD
+sed -i "s/virtualbox-guest-modules\.install\"/virtualbox-guest-modules-CLEARER\.install\"/g" ./PKGBUILD
+sed -i "s/package_linux54-virtualbox-host-modules/package_linux54-CLEARER-virtualbox-host-modules/g" ./PKGBUILD
+sed -i "s/package_linux54-virtualbox-guest-modules/package_linux54-CLEARER-virtualbox-guest-modules/g" ./PKGBUILD
+
+####################
+## Build packages ##
+####################
+
+cd "$CLEARERMANJARO_TMPDIR/clearer-manjaro-kernel"
+makepkg -Csfi --noconfirm
+
+cd "$CLEARERMANJARO_TMPDIR/clearer-manjaro-kernel-nvidia"
+makepkg -Csf --noconfirm
+
+cd "$CLEARERMANJARO_TMPDIR/acpi_call"
+makepkg -Csf --noconfirm
+
+cd "$CLEARERMANJARO_TMPDIR/spl_zfs"
+makepkg -Csf --noconfirm
+
+## virtualbox-modules ##
+
+# Build package
+cd "$CLEARERMANJARO_TMPDIR/virtualbox-modules"
+makepkg -Csf --noconfirm
+
+# Remove (now useless) MAKE-dependencies previously installed
+#echo "The following TWO lines MAY return an error. If so, it's expected."
+sudo pacman -R virtualbox-guest-dkms virtualbox-host-dkms --noconfirm
+sudo pacman -R virtualbox-guest-dkms virtualbox-host-dkms --noconfirm
+echo "The PREVIOUS TWO lines MIGHT have returned an error. If so, it's expected."
+
+#####################
+## Deploy packages ##
+#####################
+
+# Ask if deployment/install is really wanted
+echo ' '
+bash -c "read -p '[[DIAG]] Was the whole build process successful? Press [ENTER] to deploy and install Manjaro clearer!'"
+echo ' '
+
+# Remove (eventually) previously built packages
+rm -R -f "$CLEARERMANJARO_PKGS/*"
+
+
+cd "$CLEARERMANJARO_TMPDIR/clearer-manjaro-kernel"
+cp ./*.pkg.tar.xz "$CLEARERMANJARO_PKGS"
+
+cd "$CLEARERMANJARO_TMPDIR/clearer-manjaro-kernel-nvidia"
+cp ./*.pkg.tar.xz "$CLEARERMANJARO_PKGS"
+
+cd "$CLEARERMANJARO_TMPDIR/acpi_call"
+cp ./*.pkg.tar.xz "$CLEARERMANJARO_PKGS"
+
+cd "$CLEARERMANJARO_TMPDIR/spl_zfs"
+cp ./*.pkg.tar.xz "$CLEARERMANJARO_PKGS"
+
+cd "$CLEARERMANJARO_TMPDIR/virtualbox-modules"
+cp ./*host*.pkg.tar.xz "$CLEARERMANJARO_PKGS"
+
+######################
+## Install packages ##
+######################
+cd "$CLEARERMANJARO_PKGS"
+sudo pacman -U ./* --noconfirm
+trizen -S wireguard-tools uksmd --noconfirm
+
+# Ask for file cleanup
+echo ' '
+bash -c "read -p '[[DIAG]] If the installation was successful, press [ENTER] to perform a file cleanup. Hit [CTRL]+[C] to exit without cleanup.'"
+echo ' '
+
+rm -R -f "$CLEARERMANJARO_TMPDIR"
+rm -R -f "$CLEARERMANJARO_PKGS"
diff --git a/install-modules-standalone.sh b/install-modules-standalone.sh
new file mode 100755
index 0000000..60dde3b
--- /dev/null
+++ b/install-modules-standalone.sh
@@ -0,0 +1,144 @@
+#!/bin/zsh
+
+##
+## Install (1) nvidia, (2) acpi_call, (3) virtualbox_host, (4) SPL/ZFS,
+## kernel extramodules for the 'Clearer Manjaro' Kernel.
+## Note that this script is meant to REPLACE currently-installed "linux54"
+## packages (but not the kernel itself, unlike the `install-everything`
+## companion script).
+##
+## (C) 2020-* Emanuele Ballarin
+## MIT License
+##
+
+##################
+## Get packages ##
+##################
+
+# Export variables
+export CLEARERMANJARO_TMPDIR="$(pwd)/TMPDIR"
+export CLEARERMANJARO_PKGS="$(pwd)/PKGS"
+
+# Prepare build/install structure
+mkdir -p "$CLEARERMANJARO_TMPDIR"
+mkdir -p "$CLEARERMANJARO_PKGS"
+
+# Clean-up (eventual) previous build
+cd "$CLEARERMANJARO_TMPDIR"
+rm -R -f ./*
+
+# Clone relevant git repositories
+cd "$CLEARERMANJARO_TMPDIR"
+
+#git clone --recursive https://github.com/emaballarin/clearer-manjaro-kernel.git
+git clone --recursive https://github.com/emaballarin/clearer-manjaro-kernel-nvidia.git
+git clone --recursive https://gitlab.manjaro.org/packages/extra/linux54-extramodules/acpi_call.git
+git clone --recursive https://gitlab.manjaro.org/packages/extra/linux54-extramodules/virtualbox-modules.git
+git clone --recursive https://gitlab.manjaro.org/packages/extra/linux54-extramodules/spl_zfs.git
+
+###############################
+## Auto-reconfigure packages ##
+###############################
+
+# acpi_call
+cd "$CLEARERMANJARO_TMPDIR/acpi_call"
+mv ./acpi_call.install ./acpi_call-CLEARER.install
+sed -i "s/_linuxprefix=.*/_linuxprefix=linux54-CLEARER/g" ./PKGBUILD
+sed -i "s/_extramodules=.*/_extramodules=extramodules-5.4-CLEARER/g" ./PKGBUILD
+sed -i "s/install=\$_pkgname\.install.*/install=acpi_call-CLEARER\.install/g" ./PKGBUILD
+sed -i "s/acpi_call\.install\"/acpi_call-CLEARER\.install\"/g" ./PKGBUILD
+
+
+# SPL/ZFS
+cd "$CLEARERMANJARO_TMPDIR/spl_zfs"
+mv ./install ./spl_zfs-CLEARER.install
+sed -i "s/_linuxprefix=.*/_linuxprefix=linux54-CLEARER/g" ./PKGBUILD
+sed -i "s/_extramodules=.*/_extramodules=extramodules-5.4-CLEARER/g" ./PKGBUILD
+sed -i "s/install=install.*/install=spl_zfs-CLEARER\.install/g" ./PKGBUILD
+sed -i "s/install\"/spl_zfs-CLEARER\.install\"/g" ./PKGBUILD
+#sed -i "s/package_linux54-spl/package_linux54-clearer-spl/g" ./PKGBUILD
+sed -i "s/package_linux54-zfs/package_linux54-CLEARER-zfs/g" ./PKGBUILD
+
+# virtualbox-modules
+cd "$CLEARERMANJARO_TMPDIR/virtualbox-modules"
+mv ./virtualbox-host-modules.install ./virtualbox-host-modules-CLEARER.install
+mv ./virtualbox-guest-modules.install ./virtualbox-guest-modules-CLEARER.install
+sed -i "s/_linuxprefix=.*/_linuxprefix=linux54-CLEARER/g" ./PKGBUILD
+sed -i "s/_extramodules=.*/_extramodules=extramodules-5.4-CLEARER/g" ./PKGBUILD
+sed -i "s/install=virtualbox-host-modules\.install.*/install=virtualbox-host-modules-CLEARER\.install/g" ./PKGBUILD
+sed -i "s/install=virtualbox-guest-modules\.install.*/install=virtualbox-guest-modules-CLEARER\.install/g" ./PKGBUILD
+sed -i "s/virtualbox-host-modules\.install\"/virtualbox-host-modules-CLEARER\.install\"/g" ./PKGBUILD
+sed -i "s/virtualbox-guest-modules\.install\"/virtualbox-guest-modules-CLEARER\.install\"/g" ./PKGBUILD
+sed -i "s/package_linux54-virtualbox-host-modules/package_linux54-CLEARER-virtualbox-host-modules/g" ./PKGBUILD
+sed -i "s/package_linux54-virtualbox-guest-modules/package_linux54-CLEARER-virtualbox-guest-modules/g" ./PKGBUILD
+
+####################
+## Build packages ##
+####################
+
+#cd "$CLEARERMANJARO_TMPDIR/clearer-manjaro-kernel"
+#makepkg -Csfi --noconfirm
+
+cd "$CLEARERMANJARO_TMPDIR/clearer-manjaro-kernel-nvidia"
+makepkg -Csf --noconfirm
+
+cd "$CLEARERMANJARO_TMPDIR/acpi_call"
+makepkg -Csf --noconfirm
+
+cd "$CLEARERMANJARO_TMPDIR/spl_zfs"
+makepkg -Csf --noconfirm
+
+## virtualbox-modules ##
+
+# Build package
+cd "$CLEARERMANJARO_TMPDIR/virtualbox-modules"
+makepkg -Csf --noconfirm
+
+# Remove (now useless) MAKE-dependencies previously installed
+#echo "The following TWO lines MAY return an error. If so, it's expected."
+sudo pacman -R virtualbox-guest-dkms virtualbox-host-dkms --noconfirm
+sudo pacman -R virtualbox-guest-dkms virtualbox-host-dkms --noconfirm
+echo "The PREVIOUS TWO lines MIGHT have returned an error. If so, it's expected."
+
+#####################
+## Deploy packages ##
+#####################
+
+# Ask if deployment/install is really wanted
+echo ' '
+bash -c "read -p '[[DIAG]] Was the whole build process successful? Press [ENTER] to deploy and install Manjaro clearer!'"
+echo ' '
+
+# Remove (eventually) previously built packages
+rm -R -f "$CLEARERMANJARO_PKGS/*"
+
+
+#cd "$CLEARERMANJARO_TMPDIR/clearer-manjaro-kernel"
+#cp ./*.pkg.tar.xz "$CLEARERMANJARO_PKGS"
+
+cd "$CLEARERMANJARO_TMPDIR/clearer-manjaro-kernel-nvidia"
+cp ./*.pkg.tar.xz "$CLEARERMANJARO_PKGS"
+
+cd "$CLEARERMANJARO_TMPDIR/acpi_call"
+cp ./*.pkg.tar.xz "$CLEARERMANJARO_PKGS"
+
+cd "$CLEARERMANJARO_TMPDIR/spl_zfs"
+cp ./*.pkg.tar.xz "$CLEARERMANJARO_PKGS"
+
+cd "$CLEARERMANJARO_TMPDIR/virtualbox-modules"
+cp ./*host*.pkg.tar.xz "$CLEARERMANJARO_PKGS"
+
+######################
+## Install packages ##
+######################
+cd "$CLEARERMANJARO_PKGS"
+sudo pacman -U ./* --noconfirm
+trizen -S wireguard-tools uksmd --noconfirm
+
+# Ask for file cleanup
+echo ' '
+bash -c "read -p '[[DIAG]] If the installation was successful, press [ENTER] to perform a file cleanup. Hit [CTRL]+[C] to exit without cleanup.'"
+echo ' '
+
+rm -R -f "$CLEARERMANJARO_TMPDIR"
+rm -R -f "$CLEARERMANJARO_PKGS"
diff --git a/intel_uncore_frequency/inteluf_01.patch b/intel_uncore_frequency/inteluf_01.patch
new file mode 100644
index 0000000..f66ce06
--- /dev/null
+++ b/intel_uncore_frequency/inteluf_01.patch
@@ -0,0 +1,527 @@
+From: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+To: yu.chen.surf@gmail.com, andy@infradead.org, dvhart@infradead.org,
+	andy@kernel.org, lenb@kernel.org
+Cc: linux-kernel@vger.kernel.org,
+	platform-driver-x86@vger.kernel.org,
+	Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+Subject: [PATCH v3 1/2] platform/x86: Add support for Uncore frequency control
+Date: Mon, 13 Jan 2020 10:00:14 -0800
+Message-ID: <20200113180015.503314-2-srinivas.pandruvada@linux.intel.com> (raw)
+In-Reply-To: <20200113180015.503314-1-srinivas.pandruvada@linux.intel.com>
+
+Some server users set limits on the uncore frequency using MSR 620H, while
+running latency sensitive workloads. Here uncore frequency controls
+RING/LLC(last-level cache) clocks.
+
+But MSR control is not always possible from the user space, so this driver
+provides a sysfs interface to set max and min frequency limits. This MSR
+620H is a die scoped in multi-die system or package scoped in non multi-die
+systems.
+
+When this driver is loaded, a new directory is created under
+ /sys/devices/system/cpu.
+
+For example on a two package Skylake server:
+$cd /sys/devices/system/cpu/intel_uncore_frequency
+
+$ls
+package_00_die_00 package_01_die_00
+
+$ls package_00_die_00
+max_freq_khz  min_freq_khz  initial_max_freq_khz
+initial_min_freq_khz
+
+$grep . *
+    max_freq_khz:2400000
+    min_freq_khz:1200000
+    initial_max_freq_khz:2400000
+    initial_min_freq_khz:1200000
+
+Here, initial_max_freq_khz and initial_min_freq_khz are read only
+attributes to show power up or initial values of max and min frequencies
+respectively. Other attributes are read-write, so that users can modify.
+
+Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+---
+ drivers/platform/x86/Kconfig                  |  11 +
+ drivers/platform/x86/Makefile                 |   1 +
+ drivers/platform/x86/intel-uncore-frequency.c | 437 ++++++++++++++++++
+ 3 files changed, 449 insertions(+)
+ create mode 100644 drivers/platform/x86/intel-uncore-frequency.c
+
+diff --git a/drivers/platform/x86/Kconfig b/drivers/platform/x86/Kconfig
+index 27d5b40fb717..6013c3b96cfd 100644
+--- a/drivers/platform/x86/Kconfig
++++ b/drivers/platform/x86/Kconfig
+@@ -1337,6 +1337,17 @@ config PCENGINES_APU2
+ 	  To compile this driver as a module, choose M here: the module
+ 	  will be called pcengines-apuv2.
+
++config INTEL_UNCORE_FREQ_CONTROL
++	tristate "Intel Uncore frequency control driver"
++	depends on X86_64
++	help
++	  This driver allows control of uncore frequency limits on
++	  supported server platforms.
++	  Uncore frequency controls RING/LLC (last-level cache) clocks.
++
++	  To compile this driver as a module, choose M here: the module
++	  will be called intel-uncore-frequency.
++
+ source "drivers/platform/x86/intel_speed_select_if/Kconfig"
+
+ config SYSTEM76_ACPI
+diff --git a/drivers/platform/x86/Makefile b/drivers/platform/x86/Makefile
+index 42d85a00be4e..3747b1f07cf1 100644
+--- a/drivers/platform/x86/Makefile
++++ b/drivers/platform/x86/Makefile
+@@ -105,3 +105,4 @@ obj-$(CONFIG_INTEL_ATOMISP2_PM)	+= intel_atomisp2_pm.o
+ obj-$(CONFIG_PCENGINES_APU2)	+= pcengines-apuv2.o
+ obj-$(CONFIG_INTEL_SPEED_SELECT_INTERFACE) += intel_speed_select_if/
+ obj-$(CONFIG_SYSTEM76_ACPI)	+= system76_acpi.o
++obj-$(CONFIG_INTEL_UNCORE_FREQ_CONTROL)	+= intel-uncore-frequency.o
+diff --git a/drivers/platform/x86/intel-uncore-frequency.c b/drivers/platform/x86/intel-uncore-frequency.c
+new file mode 100644
+index 000000000000..2b1a0734c3f8
+--- /dev/null
++++ b/drivers/platform/x86/intel-uncore-frequency.c
+@@ -0,0 +1,437 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * Intel Uncore Frequency Setting
++ * Copyright (c) 2019, Intel Corporation.
++ * All rights reserved.
++ *
++ * Provide interface to set MSR 620 at a granularity of per die. On CPU online,
++ * one control CPU is identified per die to read/write limit. This control CPU
++ * is changed, if the CPU state is changed to offline. When the last CPU is
++ * offline in a die then remove the sysfs object for that die.
++ * The majority of actual code is related to sysfs create and read/write
++ * attributes.
++ *
++ * Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
++ */
++
++#include <linux/cpu.h>
++#include <linux/module.h>
++#include <linux/slab.h>
++#include <linux/suspend.h>
++#include <asm/cpu_device_id.h>
++#include <asm/intel-family.h>
++
++#define MSR_UNCORE_RATIO_LIMIT			0x620
++#define UNCORE_FREQ_KHZ_MULTIPLIER		100000
++
++/**
++ * struct uncore_data -	Encapsulate all uncore data
++ * @stored_uncore_data:	Last user changed MSR 620 value, which will be restored
++ *			on system resume.
++ * @initial_min_freq_khz: Sampled minimum uncore frequency at driver init
++ * @initial_max_freq_khz: Sampled maximum uncore frequency at driver init
++ * @control_cpu:	Designated CPU for a die to read/write
++ * @valid:		Mark the data valid/invalid
++ *
++ * This structure is used to encapsulate all data related to uncore sysfs
++ * settings for a die/package.
++ */
++struct uncore_data {
++	struct kobject kobj;
++	u64 stored_uncore_data;
++	u32 initial_min_freq_khz;
++	u32 initial_max_freq_khz;
++	int control_cpu;
++	bool valid;
++};
++
++#define to_uncore_data(a) container_of(a, struct uncore_data, kobj)
++
++/* Max instances for uncore data, one for each die */
++static int uncore_max_entries __read_mostly;
++/* Storage for uncore data for all instances */
++static struct uncore_data *uncore_instances;
++/* Root of the all uncore sysfs kobjs */
++struct kobject uncore_root_kobj;
++/* Stores the CPU mask of the target CPUs to use during uncore read/write */
++static cpumask_t uncore_cpu_mask;
++/* CPU online callback register instance */
++static enum cpuhp_state uncore_hp_state __read_mostly;
++/* Mutex to control all mutual exclusions */
++static DEFINE_MUTEX(uncore_lock);
++
++struct uncore_attr {
++	struct attribute attr;
++	ssize_t (*show)(struct kobject *kobj,
++			struct attribute *attr, char *buf);
++	ssize_t (*store)(struct kobject *kobj,
++			 struct attribute *attr, const char *c, ssize_t count);
++};
++
++#define define_one_uncore_ro(_name) \
++static struct uncore_attr _name = \
++__ATTR(_name, 0444, show_##_name, NULL)
++
++#define define_one_uncore_rw(_name) \
++static struct uncore_attr _name = \
++__ATTR(_name, 0644, show_##_name, store_##_name)
++
++#define show_uncore_data(member_name)					\
++	static ssize_t show_##member_name(struct kobject *kobj,         \
++					  struct attribute *attr,	\
++					  char *buf)			\
++	{                                                               \
++		struct uncore_data *data = to_uncore_data(kobj);	\
++		return scnprintf(buf, PAGE_SIZE, "%u\n",		\
++				 data->member_name);			\
++	}								\
++	define_one_uncore_ro(member_name)
++
++show_uncore_data(initial_min_freq_khz);
++show_uncore_data(initial_max_freq_khz);
++
++/* Common function to read MSR 0x620 and read min/max */
++static int uncore_read_ratio(struct uncore_data *data, unsigned int *min,
++			     unsigned int *max)
++{
++	u64 cap;
++	int ret;
++
++	ret = rdmsrl_on_cpu(data->control_cpu, MSR_UNCORE_RATIO_LIMIT, &cap);
++	if (ret)
++		return ret;
++
++	*max = (cap & 0x7F) * UNCORE_FREQ_KHZ_MULTIPLIER;
++	*min = ((cap & GENMASK(14, 8)) >> 8) * UNCORE_FREQ_KHZ_MULTIPLIER;
++
++	return 0;
++}
++
++/* Common function to set min/max ratios to be used by sysfs callbacks */
++static int uncore_write_ratio(struct uncore_data *data, unsigned int input,
++			      int set_max)
++{
++	int ret;
++	u64 cap;
++
++	mutex_lock(&uncore_lock);
++
++	input /= UNCORE_FREQ_KHZ_MULTIPLIER;
++	if (!input || input > 0x7F) {
++		ret = -EINVAL;
++		goto finish_write;
++	}
++
++	ret = rdmsrl_on_cpu(data->control_cpu, MSR_UNCORE_RATIO_LIMIT, &cap);
++	if (ret)
++		goto finish_write;
++
++	if (set_max) {
++		cap &= ~0x7F;
++		cap |= input;
++	} else  {
++		cap &= ~GENMASK(14, 8);
++		cap |= (input << 8);
++	}
++
++	ret = wrmsrl_on_cpu(data->control_cpu, MSR_UNCORE_RATIO_LIMIT, cap);
++	if (ret)
++		goto finish_write;
++
++	data->stored_uncore_data = cap;
++
++finish_write:
++	mutex_unlock(&uncore_lock);
++
++	return ret;
++}
++
++static ssize_t store_min_max_freq_khz(struct kobject *kobj,
++				      struct attribute *attr,
++				      const char *buf, ssize_t count,
++				      int min_max)
++{
++	struct uncore_data *data = to_uncore_data(kobj);
++	unsigned int input;
++
++	if (kstrtouint(buf, 10, &input))
++		return -EINVAL;
++
++	uncore_write_ratio(data, input, min_max);
++
++	return count;
++}
++
++static ssize_t show_min_max_freq_khz(struct kobject *kobj,
++				     struct attribute *attr,
++				     char *buf, int min_max)
++{
++	struct uncore_data *data = to_uncore_data(kobj);
++	unsigned int min, max;
++	int ret;
++
++	mutex_lock(&uncore_lock);
++	ret = uncore_read_ratio(data, &min, &max);
++	mutex_unlock(&uncore_lock);
++	if (ret)
++		return ret;
++
++	if (min_max)
++		return sprintf(buf, "%u\n", max);
++
++	return sprintf(buf, "%u\n", min);
++}
++
++#define store_uncore_min_max(name, min_max)				\
++	static ssize_t store_##name(struct kobject *kobj,		\
++				    struct attribute *attr,		\
++				    const char *buf, ssize_t count)	\
++	{                                                               \
++									\
++		return store_min_max_freq_khz(kobj, attr, buf, count,	\
++					      min_max);			\
++	}
++
++#define show_uncore_min_max(name, min_max)				\
++	static ssize_t show_##name(struct kobject *kobj,		\
++				   struct attribute *attr, char *buf)	\
++	{                                                               \
++									\
++		return show_min_max_freq_khz(kobj, attr, buf, min_max); \
++	}
++
++store_uncore_min_max(min_freq_khz, 0);
++store_uncore_min_max(max_freq_khz, 1);
++
++show_uncore_min_max(min_freq_khz, 0);
++show_uncore_min_max(max_freq_khz, 1);
++
++define_one_uncore_rw(min_freq_khz);
++define_one_uncore_rw(max_freq_khz);
++
++static struct attribute *uncore_attrs[] = {
++	&initial_min_freq_khz.attr,
++	&initial_max_freq_khz.attr,
++	&max_freq_khz.attr,
++	&min_freq_khz.attr,
++	NULL
++};
++
++static struct kobj_type uncore_ktype = {
++	.sysfs_ops = &kobj_sysfs_ops,
++	.default_attrs = uncore_attrs,
++};
++
++static struct kobj_type uncore_root_ktype = {
++	.sysfs_ops = &kobj_sysfs_ops,
++};
++
++/* Caller provides protection */
++static struct uncore_data *uncore_get_instance(unsigned int cpu)
++{
++	int id = topology_logical_die_id(cpu);
++
++	if (id >= 0 && id < uncore_max_entries)
++		return &uncore_instances[id];
++
++	return NULL;
++}
++
++static void uncore_add_die_entry(int cpu)
++{
++	struct uncore_data *data;
++
++	mutex_lock(&uncore_lock);
++	data = uncore_get_instance(cpu);
++	if (!data) {
++		mutex_unlock(&uncore_lock);
++		return;
++	}
++
++	if (data->valid) {
++		/* control cpu changed */
++		data->control_cpu = cpu;
++	} else {
++		char str[64];
++		int ret;
++
++		memset(data, 0, sizeof(*data));
++		sprintf(str, "package_%02d_die_%02d",
++			topology_physical_package_id(cpu),
++			topology_die_id(cpu));
++
++		uncore_read_ratio(data, &data->initial_min_freq_khz,
++				  &data->initial_max_freq_khz);
++
++		ret = kobject_init_and_add(&data->kobj, &uncore_ktype,
++					   &uncore_root_kobj, str);
++		if (!ret) {
++			data->control_cpu = cpu;
++			data->valid = true;
++		}
++	}
++	mutex_unlock(&uncore_lock);
++}
++
++/* Last CPU in this die is offline, so remove sysfs entries */
++static void uncore_remove_die_entry(int cpu)
++{
++	struct uncore_data *data;
++
++	mutex_lock(&uncore_lock);
++	data = uncore_get_instance(cpu);
++	if (data) {
++		kobject_put(&data->kobj);
++		data->control_cpu = -1;
++		data->valid = false;
++	}
++	mutex_unlock(&uncore_lock);
++}
++
++static int uncore_event_cpu_online(unsigned int cpu)
++{
++	int target;
++
++	/* Check if there is an online cpu in the package for uncore MSR */
++	target = cpumask_any_and(&uncore_cpu_mask, topology_die_cpumask(cpu));
++	if (target < nr_cpu_ids)
++		return 0;
++
++	/* Use this CPU on this die as a control CPU */
++	cpumask_set_cpu(cpu, &uncore_cpu_mask);
++	uncore_add_die_entry(cpu);
++
++	return 0;
++}
++
++static int uncore_event_cpu_offline(unsigned int cpu)
++{
++	int target;
++
++	/* Check if existing cpu is used for uncore MSRs */
++	if (!cpumask_test_and_clear_cpu(cpu, &uncore_cpu_mask))
++		return 0;
++
++	/* Find a new cpu to set uncore MSR */
++	target = cpumask_any_but(topology_die_cpumask(cpu), cpu);
++
++	if (target < nr_cpu_ids) {
++		cpumask_set_cpu(target, &uncore_cpu_mask);
++		uncore_add_die_entry(target);
++	} else {
++		uncore_remove_die_entry(cpu);
++	}
++
++	return 0;
++}
++
++static int uncore_pm_notify(struct notifier_block *nb, unsigned long mode,
++			    void *_unused)
++{
++	int cpu;
++
++	switch (mode) {
++	case PM_POST_HIBERNATION:
++	case PM_POST_RESTORE:
++	case PM_POST_SUSPEND:
++		for_each_cpu(cpu, &uncore_cpu_mask) {
++			struct uncore_data *data;
++			int ret;
++
++			data = uncore_get_instance(cpu);
++			if (!data || !data->valid || !data->stored_uncore_data)
++				continue;
++
++			ret = wrmsrl_on_cpu(cpu, MSR_UNCORE_RATIO_LIMIT,
++					    data->stored_uncore_data);
++			if (ret)
++				return ret;
++		}
++		break;
++	default:
++		break;
++	}
++	return 0;
++}
++
++static struct notifier_block uncore_pm_nb = {
++	.notifier_call = uncore_pm_notify,
++};
++
++#define ICPU(model)     { X86_VENDOR_INTEL, 6, model, X86_FEATURE_ANY, }
++
++static const struct x86_cpu_id intel_uncore_cpu_ids[] = {
++	ICPU(INTEL_FAM6_BROADWELL_G),
++	ICPU(INTEL_FAM6_BROADWELL_X),
++	ICPU(INTEL_FAM6_BROADWELL_D),
++	ICPU(INTEL_FAM6_SKYLAKE_X),
++	ICPU(INTEL_FAM6_ICELAKE_X),
++	ICPU(INTEL_FAM6_ICELAKE_D),
++	{}
++};
++
++static int __init intel_uncore_init(void)
++{
++	const struct x86_cpu_id *id;
++	int ret;
++
++	id = x86_match_cpu(intel_uncore_cpu_ids);
++	if (!id)
++		return -ENODEV;
++
++	uncore_max_entries = topology_max_packages() *
++					topology_max_die_per_package();
++	uncore_instances = kcalloc(uncore_max_entries,
++				   sizeof(*uncore_instances), GFP_KERNEL);
++	if (!uncore_instances)
++		return -ENOMEM;
++
++	ret = kobject_init_and_add(&uncore_root_kobj, &uncore_root_ktype,
++				   &cpu_subsys.dev_root->kobj,
++				   "intel_uncore_frequency");
++	if (ret)
++		goto err_free;
++
++	ret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN,
++				"platform/x86/uncore-freq:online",
++				uncore_event_cpu_online,
++				uncore_event_cpu_offline);
++	if (ret < 0)
++		goto err_rem_kobj;
++
++	uncore_hp_state = ret;
++
++	ret = register_pm_notifier(&uncore_pm_nb);
++	if (ret)
++		goto err_rem_state;
++
++	return 0;
++
++err_rem_state:
++	cpuhp_remove_state(uncore_hp_state);
++err_rem_kobj:
++	kobject_put(&uncore_root_kobj);
++err_free:
++	kfree(uncore_instances);
++
++	return ret;
++}
++module_init(intel_uncore_init)
++
++static void __exit intel_uncore_exit(void)
++{
++	int i;
++
++	unregister_pm_notifier(&uncore_pm_nb);
++	cpuhp_remove_state(uncore_hp_state);
++	for (i = 0; i < uncore_max_entries; ++i) {
++		if (uncore_instances[i].valid)
++			kobject_put(&uncore_instances[i].kobj);
++	}
++	kobject_put(&uncore_root_kobj);
++	kfree(uncore_instances);
++}
++module_exit(intel_uncore_exit)
++
++MODULE_LICENSE("GPL v2");
++MODULE_DESCRIPTION("Intel Uncore Frequency Limits Driver");
+--
+2.24.1
diff --git a/intel_uncore_frequency/inteluf_02.patch b/intel_uncore_frequency/inteluf_02.patch
new file mode 100644
index 0000000..009835d
--- /dev/null
+++ b/intel_uncore_frequency/inteluf_02.patch
@@ -0,0 +1,37 @@
+From: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+To: yu.chen.surf@gmail.com, andy@infradead.org, dvhart@infradead.org,
+	andy@kernel.org, lenb@kernel.org
+Cc: linux-kernel@vger.kernel.org,
+	platform-driver-x86@vger.kernel.org,
+	Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+Subject: [PATCH v3 2/2] MAINTAINERS: Update for the intel uncore frequency control
+Date: Mon, 13 Jan 2020 10:00:15 -0800
+Message-ID: <20200113180015.503314-3-srinivas.pandruvada@linux.intel.com> (raw)
+In-Reply-To: <20200113180015.503314-1-srinivas.pandruvada@linux.intel.com>
+
+Add an entry for drivers/platform/x86/intel-uncore-frequency.c.
+
+Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+---
+ MAINTAINERS | 6 ++++++
+ 1 file changed, 6 insertions(+)
+
+diff --git a/MAINTAINERS b/MAINTAINERS
+index 4017e6b760be..dbdadb369082 100644
+--- a/MAINTAINERS
++++ b/MAINTAINERS
+@@ -8562,6 +8562,12 @@ S:	Maintained
+ F:	arch/x86/include/asm/intel_telemetry.h
+ F:	drivers/platform/x86/intel_telemetry*
+
++INTEL UNCORE FREQUENCY CONTROL
++M:	Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
++L:	platform-driver-x86@vger.kernel.org
++S:	Maintained
++F:	drivers/platform/x86/intel-uncore-frequency.c
++
+ INTEL VIRTUAL BUTTON DRIVER
+ M:	AceLan Kao <acelan.kao@canonical.com>
+ L:	platform-driver-x86@vger.kernel.org
+--
+2.24.1
diff --git a/inteluf_01_edited.patch b/inteluf_01_edited.patch
new file mode 100644
index 0000000..bf1547b
--- /dev/null
+++ b/inteluf_01_edited.patch
@@ -0,0 +1,527 @@
+From: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+To: yu.chen.surf@gmail.com, andy@infradead.org, dvhart@infradead.org,
+	andy@kernel.org, lenb@kernel.org
+Cc: linux-kernel@vger.kernel.org,
+	platform-driver-x86@vger.kernel.org,
+	Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+Subject: [PATCH v3 1/2] platform/x86: Add support for Uncore frequency control
+Date: Mon, 13 Jan 2020 10:00:14 -0800
+Message-ID: <20200113180015.503314-2-srinivas.pandruvada@linux.intel.com> (raw)
+In-Reply-To: <20200113180015.503314-1-srinivas.pandruvada@linux.intel.com>
+
+Some server users set limits on the uncore frequency using MSR 620H, while
+running latency sensitive workloads. Here uncore frequency controls
+RING/LLC(last-level cache) clocks.
+
+But MSR control is not always possible from the user space, so this driver
+provides a sysfs interface to set max and min frequency limits. This MSR
+620H is a die scoped in multi-die system or package scoped in non multi-die
+systems.
+
+When this driver is loaded, a new directory is created under
+ /sys/devices/system/cpu.
+
+For example on a two package Skylake server:
+$cd /sys/devices/system/cpu/intel_uncore_frequency
+
+$ls
+package_00_die_00 package_01_die_00
+
+$ls package_00_die_00
+max_freq_khz  min_freq_khz  initial_max_freq_khz
+initial_min_freq_khz
+
+$grep . *
+    max_freq_khz:2400000
+    min_freq_khz:1200000
+    initial_max_freq_khz:2400000
+    initial_min_freq_khz:1200000
+
+Here, initial_max_freq_khz and initial_min_freq_khz are read only
+attributes to show power up or initial values of max and min frequencies
+respectively. Other attributes are read-write, so that users can modify.
+
+Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+---
+ drivers/platform/x86/Kconfig                  |  11 +
+ drivers/platform/x86/Makefile                 |   1 +
+ drivers/platform/x86/intel-uncore-frequency.c | 437 ++++++++++++++++++
+ 3 files changed, 449 insertions(+)
+ create mode 100644 drivers/platform/x86/intel-uncore-frequency.c
+
+diff --git a/drivers/platform/x86/Kconfig b/drivers/platform/x86/Kconfig
+index 27d5b40fb717..6013c3b96cfd 100644
+--- a/drivers/platform/x86/Kconfig
++++ b/drivers/platform/x86/Kconfig
+@@ -1337,6 +1337,17 @@ config PCENGINES_APU2
+ 	  To compile this driver as a module, choose M here: the module
+ 	  will be called pcengines-apuv2.
+
++config INTEL_UNCORE_FREQ_CONTROL
++	tristate "Intel Uncore frequency control driver"
++	depends on X86_64
++	help
++	  This driver allows control of uncore frequency limits on
++	  supported server platforms.
++	  Uncore frequency controls RING/LLC (last-level cache) clocks.
++
++	  To compile this driver as a module, choose M here: the module
++	  will be called intel-uncore-frequency.
++
+ source "drivers/platform/x86/intel_speed_select_if/Kconfig"
+
+ config SYSTEM76_ACPI
+diff --git a/drivers/platform/x86/Makefile b/drivers/platform/x86/Makefile
+index 42d85a00be4e..3747b1f07cf1 100644
+--- a/drivers/platform/x86/Makefile
++++ b/drivers/platform/x86/Makefile
+@@ -105,3 +105,4 @@ obj-$(CONFIG_I2C_MULTI_INSTANTIATE)	+= i2c-multi-instantiate.o
+ obj-$(CONFIG_INTEL_ATOMISP2_PM)	+= intel_atomisp2_pm.o
+ obj-$(CONFIG_PCENGINES_APU2)	+= pcengines-apuv2.o
+ obj-$(CONFIG_INTEL_SPEED_SELECT_INTERFACE) += intel_speed_select_if/
++obj-$(CONFIG_INTEL_UNCORE_FREQ_CONTROL)	+= intel-uncore-frequency.o
+diff --git a/drivers/platform/x86/intel-uncore-frequency.c b/drivers/platform/x86/intel-uncore-frequency.c
+new file mode 100644
+index 000000000000..2b1a0734c3f8
+--- /dev/null
++++ b/drivers/platform/x86/intel-uncore-frequency.c
+@@ -0,0 +1,437 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * Intel Uncore Frequency Setting
++ * Copyright (c) 2019, Intel Corporation.
++ * All rights reserved.
++ *
++ * Provide interface to set MSR 620 at a granularity of per die. On CPU online,
++ * one control CPU is identified per die to read/write limit. This control CPU
++ * is changed, if the CPU state is changed to offline. When the last CPU is
++ * offline in a die then remove the sysfs object for that die.
++ * The majority of actual code is related to sysfs create and read/write
++ * attributes.
++ *
++ * Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
++ */
++
++#include <linux/cpu.h>
++#include <linux/module.h>
++#include <linux/slab.h>
++#include <linux/suspend.h>
++#include <asm/cpu_device_id.h>
++#include <asm/intel-family.h>
++
++#define MSR_UNCORE_RATIO_LIMIT			0x620
++#define UNCORE_FREQ_KHZ_MULTIPLIER		100000
++
++/**
++ * struct uncore_data -	Encapsulate all uncore data
++ * @stored_uncore_data:	Last user changed MSR 620 value, which will be restored
++ *			on system resume.
++ * @initial_min_freq_khz: Sampled minimum uncore frequency at driver init
++ * @initial_max_freq_khz: Sampled maximum uncore frequency at driver init
++ * @control_cpu:	Designated CPU for a die to read/write
++ * @valid:		Mark the data valid/invalid
++ *
++ * This structure is used to encapsulate all data related to uncore sysfs
++ * settings for a die/package.
++ */
++struct uncore_data {
++	struct kobject kobj;
++	u64 stored_uncore_data;
++	u32 initial_min_freq_khz;
++	u32 initial_max_freq_khz;
++	int control_cpu;
++	bool valid;
++};
++
++#define to_uncore_data(a) container_of(a, struct uncore_data, kobj)
++
++/* Max instances for uncore data, one for each die */
++static int uncore_max_entries __read_mostly;
++/* Storage for uncore data for all instances */
++static struct uncore_data *uncore_instances;
++/* Root of the all uncore sysfs kobjs */
++struct kobject uncore_root_kobj;
++/* Stores the CPU mask of the target CPUs to use during uncore read/write */
++static cpumask_t uncore_cpu_mask;
++/* CPU online callback register instance */
++static enum cpuhp_state uncore_hp_state __read_mostly;
++/* Mutex to control all mutual exclusions */
++static DEFINE_MUTEX(uncore_lock);
++
++struct uncore_attr {
++	struct attribute attr;
++	ssize_t (*show)(struct kobject *kobj,
++			struct attribute *attr, char *buf);
++	ssize_t (*store)(struct kobject *kobj,
++			 struct attribute *attr, const char *c, ssize_t count);
++};
++
++#define define_one_uncore_ro(_name) \
++static struct uncore_attr _name = \
++__ATTR(_name, 0444, show_##_name, NULL)
++
++#define define_one_uncore_rw(_name) \
++static struct uncore_attr _name = \
++__ATTR(_name, 0644, show_##_name, store_##_name)
++
++#define show_uncore_data(member_name)					\
++	static ssize_t show_##member_name(struct kobject *kobj,         \
++					  struct attribute *attr,	\
++					  char *buf)			\
++	{                                                               \
++		struct uncore_data *data = to_uncore_data(kobj);	\
++		return scnprintf(buf, PAGE_SIZE, "%u\n",		\
++				 data->member_name);			\
++	}								\
++	define_one_uncore_ro(member_name)
++
++show_uncore_data(initial_min_freq_khz);
++show_uncore_data(initial_max_freq_khz);
++
++/* Common function to read MSR 0x620 and read min/max */
++static int uncore_read_ratio(struct uncore_data *data, unsigned int *min,
++			     unsigned int *max)
++{
++	u64 cap;
++	int ret;
++
++	ret = rdmsrl_on_cpu(data->control_cpu, MSR_UNCORE_RATIO_LIMIT, &cap);
++	if (ret)
++		return ret;
++
++	*max = (cap & 0x7F) * UNCORE_FREQ_KHZ_MULTIPLIER;
++	*min = ((cap & GENMASK(14, 8)) >> 8) * UNCORE_FREQ_KHZ_MULTIPLIER;
++
++	return 0;
++}
++
++/* Common function to set min/max ratios to be used by sysfs callbacks */
++static int uncore_write_ratio(struct uncore_data *data, unsigned int input,
++			      int set_max)
++{
++	int ret;
++	u64 cap;
++
++	mutex_lock(&uncore_lock);
++
++	input /= UNCORE_FREQ_KHZ_MULTIPLIER;
++	if (!input || input > 0x7F) {
++		ret = -EINVAL;
++		goto finish_write;
++	}
++
++	ret = rdmsrl_on_cpu(data->control_cpu, MSR_UNCORE_RATIO_LIMIT, &cap);
++	if (ret)
++		goto finish_write;
++
++	if (set_max) {
++		cap &= ~0x7F;
++		cap |= input;
++	} else  {
++		cap &= ~GENMASK(14, 8);
++		cap |= (input << 8);
++	}
++
++	ret = wrmsrl_on_cpu(data->control_cpu, MSR_UNCORE_RATIO_LIMIT, cap);
++	if (ret)
++		goto finish_write;
++
++	data->stored_uncore_data = cap;
++
++finish_write:
++	mutex_unlock(&uncore_lock);
++
++	return ret;
++}
++
++static ssize_t store_min_max_freq_khz(struct kobject *kobj,
++				      struct attribute *attr,
++				      const char *buf, ssize_t count,
++				      int min_max)
++{
++	struct uncore_data *data = to_uncore_data(kobj);
++	unsigned int input;
++
++	if (kstrtouint(buf, 10, &input))
++		return -EINVAL;
++
++	uncore_write_ratio(data, input, min_max);
++
++	return count;
++}
++
++static ssize_t show_min_max_freq_khz(struct kobject *kobj,
++				     struct attribute *attr,
++				     char *buf, int min_max)
++{
++	struct uncore_data *data = to_uncore_data(kobj);
++	unsigned int min, max;
++	int ret;
++
++	mutex_lock(&uncore_lock);
++	ret = uncore_read_ratio(data, &min, &max);
++	mutex_unlock(&uncore_lock);
++	if (ret)
++		return ret;
++
++	if (min_max)
++		return sprintf(buf, "%u\n", max);
++
++	return sprintf(buf, "%u\n", min);
++}
++
++#define store_uncore_min_max(name, min_max)				\
++	static ssize_t store_##name(struct kobject *kobj,		\
++				    struct attribute *attr,		\
++				    const char *buf, ssize_t count)	\
++	{                                                               \
++									\
++		return store_min_max_freq_khz(kobj, attr, buf, count,	\
++					      min_max);			\
++	}
++
++#define show_uncore_min_max(name, min_max)				\
++	static ssize_t show_##name(struct kobject *kobj,		\
++				   struct attribute *attr, char *buf)	\
++	{                                                               \
++									\
++		return show_min_max_freq_khz(kobj, attr, buf, min_max); \
++	}
++
++store_uncore_min_max(min_freq_khz, 0);
++store_uncore_min_max(max_freq_khz, 1);
++
++show_uncore_min_max(min_freq_khz, 0);
++show_uncore_min_max(max_freq_khz, 1);
++
++define_one_uncore_rw(min_freq_khz);
++define_one_uncore_rw(max_freq_khz);
++
++static struct attribute *uncore_attrs[] = {
++	&initial_min_freq_khz.attr,
++	&initial_max_freq_khz.attr,
++	&max_freq_khz.attr,
++	&min_freq_khz.attr,
++	NULL
++};
++
++static struct kobj_type uncore_ktype = {
++	.sysfs_ops = &kobj_sysfs_ops,
++	.default_attrs = uncore_attrs,
++};
++
++static struct kobj_type uncore_root_ktype = {
++	.sysfs_ops = &kobj_sysfs_ops,
++};
++
++/* Caller provides protection */
++static struct uncore_data *uncore_get_instance(unsigned int cpu)
++{
++	int id = topology_logical_die_id(cpu);
++
++	if (id >= 0 && id < uncore_max_entries)
++		return &uncore_instances[id];
++
++	return NULL;
++}
++
++static void uncore_add_die_entry(int cpu)
++{
++	struct uncore_data *data;
++
++	mutex_lock(&uncore_lock);
++	data = uncore_get_instance(cpu);
++	if (!data) {
++		mutex_unlock(&uncore_lock);
++		return;
++	}
++
++	if (data->valid) {
++		/* control cpu changed */
++		data->control_cpu = cpu;
++	} else {
++		char str[64];
++		int ret;
++
++		memset(data, 0, sizeof(*data));
++		sprintf(str, "package_%02d_die_%02d",
++			topology_physical_package_id(cpu),
++			topology_die_id(cpu));
++
++		uncore_read_ratio(data, &data->initial_min_freq_khz,
++				  &data->initial_max_freq_khz);
++
++		ret = kobject_init_and_add(&data->kobj, &uncore_ktype,
++					   &uncore_root_kobj, str);
++		if (!ret) {
++			data->control_cpu = cpu;
++			data->valid = true;
++		}
++	}
++	mutex_unlock(&uncore_lock);
++}
++
++/* Last CPU in this die is offline, so remove sysfs entries */
++static void uncore_remove_die_entry(int cpu)
++{
++	struct uncore_data *data;
++
++	mutex_lock(&uncore_lock);
++	data = uncore_get_instance(cpu);
++	if (data) {
++		kobject_put(&data->kobj);
++		data->control_cpu = -1;
++		data->valid = false;
++	}
++	mutex_unlock(&uncore_lock);
++}
++
++static int uncore_event_cpu_online(unsigned int cpu)
++{
++	int target;
++
++	/* Check if there is an online cpu in the package for uncore MSR */
++	target = cpumask_any_and(&uncore_cpu_mask, topology_die_cpumask(cpu));
++	if (target < nr_cpu_ids)
++		return 0;
++
++	/* Use this CPU on this die as a control CPU */
++	cpumask_set_cpu(cpu, &uncore_cpu_mask);
++	uncore_add_die_entry(cpu);
++
++	return 0;
++}
++
++static int uncore_event_cpu_offline(unsigned int cpu)
++{
++	int target;
++
++	/* Check if existing cpu is used for uncore MSRs */
++	if (!cpumask_test_and_clear_cpu(cpu, &uncore_cpu_mask))
++		return 0;
++
++	/* Find a new cpu to set uncore MSR */
++	target = cpumask_any_but(topology_die_cpumask(cpu), cpu);
++
++	if (target < nr_cpu_ids) {
++		cpumask_set_cpu(target, &uncore_cpu_mask);
++		uncore_add_die_entry(target);
++	} else {
++		uncore_remove_die_entry(cpu);
++	}
++
++	return 0;
++}
++
++static int uncore_pm_notify(struct notifier_block *nb, unsigned long mode,
++			    void *_unused)
++{
++	int cpu;
++
++	switch (mode) {
++	case PM_POST_HIBERNATION:
++	case PM_POST_RESTORE:
++	case PM_POST_SUSPEND:
++		for_each_cpu(cpu, &uncore_cpu_mask) {
++			struct uncore_data *data;
++			int ret;
++
++			data = uncore_get_instance(cpu);
++			if (!data || !data->valid || !data->stored_uncore_data)
++				continue;
++
++			ret = wrmsrl_on_cpu(cpu, MSR_UNCORE_RATIO_LIMIT,
++					    data->stored_uncore_data);
++			if (ret)
++				return ret;
++		}
++		break;
++	default:
++		break;
++	}
++	return 0;
++}
++
++static struct notifier_block uncore_pm_nb = {
++	.notifier_call = uncore_pm_notify,
++};
++
++#define ICPU(model)     { X86_VENDOR_INTEL, 6, model, X86_FEATURE_ANY, }
++
++static const struct x86_cpu_id intel_uncore_cpu_ids[] = {
++	ICPU(INTEL_FAM6_BROADWELL_G),
++	ICPU(INTEL_FAM6_BROADWELL_X),
++	ICPU(INTEL_FAM6_BROADWELL_D),
++	ICPU(INTEL_FAM6_SKYLAKE_X),
++	ICPU(INTEL_FAM6_ICELAKE_X),
++	ICPU(INTEL_FAM6_ICELAKE_D),
++	{}
++};
++
++static int __init intel_uncore_init(void)
++{
++	const struct x86_cpu_id *id;
++	int ret;
++
++	id = x86_match_cpu(intel_uncore_cpu_ids);
++	if (!id)
++		return -ENODEV;
++
++	uncore_max_entries = topology_max_packages() *
++					topology_max_die_per_package();
++	uncore_instances = kcalloc(uncore_max_entries,
++				   sizeof(*uncore_instances), GFP_KERNEL);
++	if (!uncore_instances)
++		return -ENOMEM;
++
++	ret = kobject_init_and_add(&uncore_root_kobj, &uncore_root_ktype,
++				   &cpu_subsys.dev_root->kobj,
++				   "intel_uncore_frequency");
++	if (ret)
++		goto err_free;
++
++	ret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN,
++				"platform/x86/uncore-freq:online",
++				uncore_event_cpu_online,
++				uncore_event_cpu_offline);
++	if (ret < 0)
++		goto err_rem_kobj;
++
++	uncore_hp_state = ret;
++
++	ret = register_pm_notifier(&uncore_pm_nb);
++	if (ret)
++		goto err_rem_state;
++
++	return 0;
++
++err_rem_state:
++	cpuhp_remove_state(uncore_hp_state);
++err_rem_kobj:
++	kobject_put(&uncore_root_kobj);
++err_free:
++	kfree(uncore_instances);
++
++	return ret;
++}
++module_init(intel_uncore_init)
++
++static void __exit intel_uncore_exit(void)
++{
++	int i;
++
++	unregister_pm_notifier(&uncore_pm_nb);
++	cpuhp_remove_state(uncore_hp_state);
++	for (i = 0; i < uncore_max_entries; ++i) {
++		if (uncore_instances[i].valid)
++			kobject_put(&uncore_instances[i].kobj);
++	}
++	kobject_put(&uncore_root_kobj);
++	kfree(uncore_instances);
++}
++module_exit(intel_uncore_exit)
++
++MODULE_LICENSE("GPL v2");
++MODULE_DESCRIPTION("Intel Uncore Frequency Limits Driver");
+--
+2.24.1
diff --git a/inteluf_02.patch b/inteluf_02.patch
new file mode 100644
index 0000000..009835d
--- /dev/null
+++ b/inteluf_02.patch
@@ -0,0 +1,37 @@
+From: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+To: yu.chen.surf@gmail.com, andy@infradead.org, dvhart@infradead.org,
+	andy@kernel.org, lenb@kernel.org
+Cc: linux-kernel@vger.kernel.org,
+	platform-driver-x86@vger.kernel.org,
+	Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+Subject: [PATCH v3 2/2] MAINTAINERS: Update for the intel uncore frequency control
+Date: Mon, 13 Jan 2020 10:00:15 -0800
+Message-ID: <20200113180015.503314-3-srinivas.pandruvada@linux.intel.com> (raw)
+In-Reply-To: <20200113180015.503314-1-srinivas.pandruvada@linux.intel.com>
+
+Add an entry for drivers/platform/x86/intel-uncore-frequency.c.
+
+Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+---
+ MAINTAINERS | 6 ++++++
+ 1 file changed, 6 insertions(+)
+
+diff --git a/MAINTAINERS b/MAINTAINERS
+index 4017e6b760be..dbdadb369082 100644
+--- a/MAINTAINERS
++++ b/MAINTAINERS
+@@ -8562,6 +8562,12 @@ S:	Maintained
+ F:	arch/x86/include/asm/intel_telemetry.h
+ F:	drivers/platform/x86/intel_telemetry*
+
++INTEL UNCORE FREQUENCY CONTROL
++M:	Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
++L:	platform-driver-x86@vger.kernel.org
++S:	Maintained
++F:	drivers/platform/x86/intel-uncore-frequency.c
++
+ INTEL VIRTUAL BUTTON DRIVER
+ M:	AceLan Kao <acelan.kao@canonical.com>
+ L:	platform-driver-x86@vger.kernel.org
+--
+2.24.1
diff --git a/isst/isst_01.patch b/isst/isst_01.patch
new file mode 100644
index 0000000..82635e3
--- /dev/null
+++ b/isst/isst_01.patch
@@ -0,0 +1,41 @@
+From: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+To: andriy.shevchenko@intel.com, prarit@redhat.com
+Cc: platform-driver-x86@vger.kernel.org,
+	linux-kernel@vger.kernel.org,
+	Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+Subject: [PATCH 1/5] platform/x86: ISST: Allow additional core-power mailbox commands
+Date: Tue, 14 Jan 2020 11:22:13 -0800
+Message-ID: <20200114192217.580364-2-srinivas.pandruvada@linux.intel.com> (raw)
+In-Reply-To: <20200114192217.580364-1-srinivas.pandruvada@linux.intel.com>
+
+To discover core-power capability, some new mailbox commands are added. Allow
+those commands to execute.
+
+Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+---
+ drivers/platform/x86/intel_speed_select_if/isst_if_common.c | 3 +++
+ 1 file changed, 3 insertions(+)
+
+diff --git a/drivers/platform/x86/intel_speed_select_if/isst_if_common.c b/drivers/platform/x86/intel_speed_select_if/isst_if_common.c
+index 3de5a3c66529..0c2aa22c7a12 100644
+--- a/drivers/platform/x86/intel_speed_select_if/isst_if_common.c
++++ b/drivers/platform/x86/intel_speed_select_if/isst_if_common.c
+@@ -50,6 +50,8 @@ static const struct isst_valid_cmd_ranges isst_valid_cmds[] = {
+ 	{0x7F, 0x00, 0x0B},
+ 	{0x7F, 0x10, 0x12},
+ 	{0x7F, 0x20, 0x23},
++	{0x94, 0x03, 0x03},
++	{0x95, 0x03, 0x03},
+ };
+
+ static const struct isst_cmd_set_req_type isst_cmd_set_reqs[] = {
+@@ -59,6 +61,7 @@ static const struct isst_cmd_set_req_type isst_cmd_set_reqs[] = {
+ 	{0xD0, 0x03, 0x08},
+ 	{0x7F, 0x02, 0x00},
+ 	{0x7F, 0x08, 0x00},
++	{0x95, 0x03, 0x03},
+ };
+
+ struct isst_cmd {
+--
+2.24.1
diff --git a/isst/isst_02.patch b/isst/isst_02.patch
new file mode 100644
index 0000000..547918f
--- /dev/null
+++ b/isst/isst_02.patch
@@ -0,0 +1,156 @@
+From: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+To: andriy.shevchenko@intel.com, prarit@redhat.com
+Cc: platform-driver-x86@vger.kernel.org,
+	linux-kernel@vger.kernel.org,
+	Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+Subject: [PATCH 2/5] tools/power/x86/intel-speed-select: Add support for core-power discovery
+Date: Tue, 14 Jan 2020 11:22:14 -0800
+Message-ID: <20200114192217.580364-3-srinivas.pandruvada@linux.intel.com> (raw)
+In-Reply-To: <20200114192217.580364-1-srinivas.pandruvada@linux.intel.com>
+
+It is possible that BIOS may not enable core-power feature. In this case
+this additional interface will allow to enable from this utility. Also
+the information dump, includes the current status of core-power.
+
+Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+---
+ .../power/x86/intel-speed-select/isst-core.c  | 55 +++++++++++++++++++
+ .../x86/intel-speed-select/isst-display.c     | 11 ++++
+ tools/power/x86/intel-speed-select/isst.h     |  6 ++
+ 3 files changed, 72 insertions(+)
+
+diff --git a/tools/power/x86/intel-speed-select/isst-core.c b/tools/power/x86/intel-speed-select/isst-core.c
+index d14c7bcd327a..81a119f688a3 100644
+--- a/tools/power/x86/intel-speed-select/isst-core.c
++++ b/tools/power/x86/intel-speed-select/isst-core.c
+@@ -6,6 +6,44 @@
+
+ #include "isst.h"
+
++int isst_write_pm_config(int cpu, int cp_state)
++{
++	unsigned int req, resp;
++	int ret;
++
++	if (cp_state)
++		req = BIT(16);
++	else
++		req = 0;
++
++	ret = isst_send_mbox_command(cpu, WRITE_PM_CONFIG, PM_FEATURE, 0, req,
++				     &resp);
++	if (ret)
++		return ret;
++
++	debug_printf("cpu:%d WRITE_PM_CONFIG resp:%x\n", cpu, resp);
++
++	return 0;
++}
++
++int isst_read_pm_config(int cpu, int *cp_state, int *cp_cap)
++{
++	unsigned int resp;
++	int ret;
++
++	ret = isst_send_mbox_command(cpu, READ_PM_CONFIG, PM_FEATURE, 0, 0,
++				     &resp);
++	if (ret)
++		return ret;
++
++	debug_printf("cpu:%d READ_PM_CONFIG resp:%x\n", cpu, resp);
++
++	*cp_state = resp & BIT(16);
++	*cp_cap = resp & BIT(0) ? 1 : 0;
++
++	return 0;
++}
++
+ int isst_get_ctdp_levels(int cpu, struct isst_pkg_ctdp *pkg_dev)
+ {
+ 	unsigned int resp;
+@@ -36,6 +74,7 @@ int isst_get_ctdp_levels(int cpu, struct isst_pkg_ctdp *pkg_dev)
+ int isst_get_ctdp_control(int cpu, int config_index,
+ 			  struct isst_pkg_ctdp_level_info *ctdp_level)
+ {
++	int cp_state, cp_cap;
+ 	unsigned int resp;
+ 	int ret;
+
+@@ -50,6 +89,15 @@ int isst_get_ctdp_control(int cpu, int config_index,
+ 	ctdp_level->fact_enabled = !!(resp & BIT(16));
+ 	ctdp_level->pbf_enabled = !!(resp & BIT(17));
+
++	ret = isst_read_pm_config(cpu, &cp_state, &cp_cap);
++	if (ret) {
++		debug_printf("cpu:%d pm_config is not supported \n", cpu);
++	} else {
++		debug_printf("cpu:%d pm_config SST-CP state:%d cap:%d \n", cpu, cp_state, cp_cap);
++		ctdp_level->sst_cp_support = cp_cap;
++		ctdp_level->sst_cp_enabled = cp_state;
++	}
++
+ 	debug_printf(
+ 		"cpu:%d CONFIG_TDP_GET_TDP_CONTROL resp:%x fact_support:%d pbf_support: %d fact_enabled:%d pbf_enabled:%d\n",
+ 		cpu, resp, ctdp_level->fact_support, ctdp_level->pbf_support,
+@@ -779,6 +827,13 @@ int isst_pm_qos_config(int cpu, int enable_clos, int priority_type)
+ 			debug_printf("Turbo-freq feature must be disabled first\n");
+ 			return -EINVAL;
+ 		}
++		ret = isst_write_pm_config(cpu, 0);
++		if (ret)
++			perror("isst_write_pm_config\n");
++	} else {
++		ret = isst_write_pm_config(cpu, 1);
++		if (ret)
++			perror("isst_write_pm_config\n");
+ 	}
+
+ 	ret = isst_send_mbox_command(cpu, CONFIG_CLOS, CLOS_PM_QOS_CONFIG, 0, 0,
+diff --git a/tools/power/x86/intel-speed-select/isst-display.c b/tools/power/x86/intel-speed-select/isst-display.c
+index 040dd09d5eee..1d1439036c12 100644
+--- a/tools/power/x86/intel-speed-select/isst-display.c
++++ b/tools/power/x86/intel-speed-select/isst-display.c
+@@ -418,6 +418,17 @@ void isst_ctdp_display_information(int cpu, FILE *outf, int tdp_level,
+ 			snprintf(value, sizeof(value), "unsupported");
+ 		format_and_print(outf, base_level + 4, header, value);
+
++		snprintf(header, sizeof(header),
++			 "speed-select-core-power");
++		if (ctdp_level->sst_cp_support) {
++			if (ctdp_level->sst_cp_enabled)
++				snprintf(value, sizeof(value), "enabled");
++			else
++				snprintf(value, sizeof(value), "disabled");
++		} else
++			snprintf(value, sizeof(value), "unsupported");
++		format_and_print(outf, base_level + 4, header, value);
++
+ 		if (is_clx_n_platform()) {
+ 			if (ctdp_level->pbf_support)
+ 				_isst_pbf_display_information(cpu, outf,
+diff --git a/tools/power/x86/intel-speed-select/isst.h b/tools/power/x86/intel-speed-select/isst.h
+index cdf0f8a6dbbf..ad5aa6341d0f 100644
+--- a/tools/power/x86/intel-speed-select/isst.h
++++ b/tools/power/x86/intel-speed-select/isst.h
+@@ -69,6 +69,10 @@
+ #define PM_CLOS_OFFSET				0x08
+ #define PQR_ASSOC_OFFSET			0x20
+
++#define READ_PM_CONFIG				0x94
++#define WRITE_PM_CONFIG				0x95
++#define PM_FEATURE				0x03
++
+ #define DISP_FREQ_MULTIPLIER 100
+
+ struct isst_clos_config {
+@@ -119,6 +123,8 @@ struct isst_pkg_ctdp_level_info {
+ 	int pbf_support;
+ 	int fact_enabled;
+ 	int pbf_enabled;
++	int sst_cp_support;
++	int sst_cp_enabled;
+ 	int tdp_ratio;
+ 	int active;
+ 	int tdp_control;
+--
+2.24.1
diff --git a/isst/isst_03.patch b/isst/isst_03.patch
new file mode 100644
index 0000000..ad5225d
--- /dev/null
+++ b/isst/isst_03.patch
@@ -0,0 +1,93 @@
+From: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+To: andriy.shevchenko@intel.com, prarit@redhat.com
+Cc: platform-driver-x86@vger.kernel.org,
+	linux-kernel@vger.kernel.org,
+	Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+Subject: [PATCH 3/5] tools/power/x86/intel-speed-select: Fix result display for turbo-freq auto mode
+Date: Tue, 14 Jan 2020 11:22:15 -0800
+Message-ID: <20200114192217.580364-4-srinivas.pandruvada@linux.intel.com> (raw)
+In-Reply-To: <20200114192217.580364-1-srinivas.pandruvada@linux.intel.com>
+
+The turbo-freq enable with auto mode, prints result for the last possible
+CPU, which is not correct when either CPU is not present or user wants
+command to be limited to a single die/package. For example, in the
+below command user wants to limit to die/package 0, but the
+"turbo-freq --auto" result is displayed using the other package.
+
+$ sudo intel-speed-select -c 0 turbo-freq enable -a
+Intel(R) Speed Select Technology
+ package-0
+  die-0
+    cpu-0
+      turbo-freq
+        enable:success
+ package--1
+  die-0
+    cpu-31
+      turbo-freq --auto
+        enable:success
+
+Since we do have to traverse all CPUs, don't display CPU info for
+"turbo-freq --auto", as we already displayed the result for
+turbo-freq enable with the CPU information.
+
+With the fix, the same command results in:
+
+$ sudo intel-speed-select -c 0 turbo-freq enable -a
+Intel(R) Speed Select Technology
+package-0
+  die-0
+    cpu-0
+      turbo-freq
+        enable:success
+      turbo-freq --auto
+        enable:success
+
+Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+---
+ tools/power/x86/intel-speed-select/isst-config.c |  2 +-
+ .../power/x86/intel-speed-select/isst-display.c  | 16 +++++++++-------
+ 2 files changed, 10 insertions(+), 8 deletions(-)
+
+diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
+index 944183f9ed5a..e22a694e6410 100644
+--- a/tools/power/x86/intel-speed-select/isst-config.c
++++ b/tools/power/x86/intel-speed-select/isst-config.c
+@@ -1638,7 +1638,7 @@ static void set_fact_enable(int arg)
+ 			if (ret)
+ 				goto error_disp;
+ 		}
+-		isst_display_result(i, outf, "turbo-freq --auto", "enable", 0);
++		isst_display_result(-1, outf, "turbo-freq --auto", "enable", 0);
+ 	}
+
+ 	return;
+diff --git a/tools/power/x86/intel-speed-select/isst-display.c b/tools/power/x86/intel-speed-select/isst-display.c
+index 1d1439036c12..4fb0c1d49d64 100644
+--- a/tools/power/x86/intel-speed-select/isst-display.c
++++ b/tools/power/x86/intel-speed-select/isst-display.c
+@@ -645,13 +645,15 @@ void isst_display_result(int cpu, FILE *outf, char *feature, char *cmd,
+ 	char header[256];
+ 	char value[256];
+
+-	snprintf(header, sizeof(header), "package-%d",
+-		 get_physical_package_id(cpu));
+-	format_and_print(outf, 1, header, NULL);
+-	snprintf(header, sizeof(header), "die-%d", get_physical_die_id(cpu));
+-	format_and_print(outf, 2, header, NULL);
+-	snprintf(header, sizeof(header), "cpu-%d", cpu);
+-	format_and_print(outf, 3, header, NULL);
++	if (cpu >= 0) {
++		snprintf(header, sizeof(header), "package-%d",
++			 get_physical_package_id(cpu));
++		format_and_print(outf, 1, header, NULL);
++		snprintf(header, sizeof(header), "die-%d", get_physical_die_id(cpu));
++		format_and_print(outf, 2, header, NULL);
++		snprintf(header, sizeof(header), "cpu-%d", cpu);
++		format_and_print(outf, 3, header, NULL);
++	}
+ 	snprintf(header, sizeof(header), "%s", feature);
+ 	format_and_print(outf, 4, header, NULL);
+ 	snprintf(header, sizeof(header), "%s", cmd);
+--
+2.24.1
diff --git a/isst/isst_04.patch b/isst/isst_04.patch
new file mode 100644
index 0000000..7807aba
--- /dev/null
+++ b/isst/isst_04.patch
@@ -0,0 +1,82 @@
+From: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+To: andriy.shevchenko@intel.com, prarit@redhat.com
+Cc: platform-driver-x86@vger.kernel.org,
+	linux-kernel@vger.kernel.org,
+	Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+Subject: [PATCH 4/5] tools/power/x86/intel-speed-select: Change the order for clos disable
+Date: Tue, 14 Jan 2020 11:22:16 -0800
+Message-ID: <20200114192217.580364-5-srinivas.pandruvada@linux.intel.com> (raw)
+In-Reply-To: <20200114192217.580364-1-srinivas.pandruvada@linux.intel.com>
+
+In turbo-freq or base-freq auto mode, for disable, first disable the feature and
+then disable clos.
+
+Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+---
+ .../x86/intel-speed-select/isst-config.c      | 30 +++++++++----------
+ 1 file changed, 14 insertions(+), 16 deletions(-)
+
+diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
+index e22a694e6410..84baba34d311 100644
+--- a/tools/power/x86/intel-speed-select/isst-config.c
++++ b/tools/power/x86/intel-speed-select/isst-config.c
+@@ -1384,14 +1384,10 @@ static void set_pbf_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
+ 		goto disp_result;
+ 	}
+
+-	if (auto_mode) {
+-		if (status) {
+-			ret = set_pbf_core_power(cpu);
+-			if (ret)
+-				goto disp_result;
+-		} else {
+-			isst_pm_qos_config(cpu, 0, 0);
+-		}
++	if (auto_mode && status) {
++		ret = set_pbf_core_power(cpu);
++		if (ret)
++			goto disp_result;
+ 	}
+
+ 	ret = isst_set_pbf_fact_status(cpu, 1, status);
+@@ -1408,6 +1404,9 @@ static void set_pbf_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
+ 		}
+ 	}
+
++	if (auto_mode && !status)
++		isst_pm_qos_config(cpu, 0, 0);
++
+ disp_result:
+ 	if (status)
+ 		isst_display_result(cpu, outf, "base-freq", "enable",
+@@ -1496,14 +1495,10 @@ static void set_fact_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
+ 	int ret;
+ 	int status = *(int *)arg4;
+
+-	if (auto_mode) {
+-		if (status) {
+-			ret = isst_pm_qos_config(cpu, 1, 1);
+-			if (ret)
+-				goto disp_results;
+-		} else {
+-			isst_pm_qos_config(cpu, 0, 0);
+-		}
++	if (auto_mode && status) {
++		ret = isst_pm_qos_config(cpu, 1, 1);
++		if (ret)
++			goto disp_results;
+ 	}
+
+ 	ret = isst_set_pbf_fact_status(cpu, 0, status);
+@@ -1524,6 +1519,9 @@ static void set_fact_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
+ 			ret = isst_set_trl(cpu, fact_trl);
+ 		if (ret && auto_mode)
+ 			isst_pm_qos_config(cpu, 0, 0);
++	} else {
++		if (auto_mode)
++			isst_pm_qos_config(cpu, 0, 0);
+ 	}
+
+ disp_results:
+--
+2.24.1
diff --git a/isst/isst_05.patch b/isst/isst_05.patch
new file mode 100644
index 0000000..cef433c
--- /dev/null
+++ b/isst/isst_05.patch
@@ -0,0 +1,32 @@
+From: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+To: andriy.shevchenko@intel.com, prarit@redhat.com
+Cc: platform-driver-x86@vger.kernel.org,
+	linux-kernel@vger.kernel.org,
+	Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+Subject: [PATCH 5/5] tools/power/x86/intel-speed-select: Update version
+Date: Tue, 14 Jan 2020 11:22:17 -0800
+Message-ID: <20200114192217.580364-6-srinivas.pandruvada@linux.intel.com> (raw)
+In-Reply-To: <20200114192217.580364-1-srinivas.pandruvada@linux.intel.com>
+
+As we added new set of mailbox commands, increment version.
+
+Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+---
+ tools/power/x86/intel-speed-select/isst-config.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
+index 84baba34d311..2b2b8167c65b 100644
+--- a/tools/power/x86/intel-speed-select/isst-config.c
++++ b/tools/power/x86/intel-speed-select/isst-config.c
+@@ -15,7 +15,7 @@ struct process_cmd_struct {
+ 	int arg;
+ };
+
+-static const char *version_str = "v1.1";
++static const char *version_str = "v1.2";
+ static const int supported_api_ver = 1;
+ static struct isst_if_platform_info isst_platform_info;
+ static char *progname;
+--
+2.24.1
diff --git a/isst_01.patch b/isst_01.patch
new file mode 100644
index 0000000..82635e3
--- /dev/null
+++ b/isst_01.patch
@@ -0,0 +1,41 @@
+From: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+To: andriy.shevchenko@intel.com, prarit@redhat.com
+Cc: platform-driver-x86@vger.kernel.org,
+	linux-kernel@vger.kernel.org,
+	Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+Subject: [PATCH 1/5] platform/x86: ISST: Allow additional core-power mailbox commands
+Date: Tue, 14 Jan 2020 11:22:13 -0800
+Message-ID: <20200114192217.580364-2-srinivas.pandruvada@linux.intel.com> (raw)
+In-Reply-To: <20200114192217.580364-1-srinivas.pandruvada@linux.intel.com>
+
+To discover core-power capability, some new mailbox commands are added. Allow
+those commands to execute.
+
+Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+---
+ drivers/platform/x86/intel_speed_select_if/isst_if_common.c | 3 +++
+ 1 file changed, 3 insertions(+)
+
+diff --git a/drivers/platform/x86/intel_speed_select_if/isst_if_common.c b/drivers/platform/x86/intel_speed_select_if/isst_if_common.c
+index 3de5a3c66529..0c2aa22c7a12 100644
+--- a/drivers/platform/x86/intel_speed_select_if/isst_if_common.c
++++ b/drivers/platform/x86/intel_speed_select_if/isst_if_common.c
+@@ -50,6 +50,8 @@ static const struct isst_valid_cmd_ranges isst_valid_cmds[] = {
+ 	{0x7F, 0x00, 0x0B},
+ 	{0x7F, 0x10, 0x12},
+ 	{0x7F, 0x20, 0x23},
++	{0x94, 0x03, 0x03},
++	{0x95, 0x03, 0x03},
+ };
+
+ static const struct isst_cmd_set_req_type isst_cmd_set_reqs[] = {
+@@ -59,6 +61,7 @@ static const struct isst_cmd_set_req_type isst_cmd_set_reqs[] = {
+ 	{0xD0, 0x03, 0x08},
+ 	{0x7F, 0x02, 0x00},
+ 	{0x7F, 0x08, 0x00},
++	{0x95, 0x03, 0x03},
+ };
+
+ struct isst_cmd {
+--
+2.24.1
diff --git a/isst_02.patch b/isst_02.patch
new file mode 100644
index 0000000..547918f
--- /dev/null
+++ b/isst_02.patch
@@ -0,0 +1,156 @@
+From: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+To: andriy.shevchenko@intel.com, prarit@redhat.com
+Cc: platform-driver-x86@vger.kernel.org,
+	linux-kernel@vger.kernel.org,
+	Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+Subject: [PATCH 2/5] tools/power/x86/intel-speed-select: Add support for core-power discovery
+Date: Tue, 14 Jan 2020 11:22:14 -0800
+Message-ID: <20200114192217.580364-3-srinivas.pandruvada@linux.intel.com> (raw)
+In-Reply-To: <20200114192217.580364-1-srinivas.pandruvada@linux.intel.com>
+
+It is possible that BIOS may not enable core-power feature. In this case
+this additional interface will allow to enable from this utility. Also
+the information dump, includes the current status of core-power.
+
+Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+---
+ .../power/x86/intel-speed-select/isst-core.c  | 55 +++++++++++++++++++
+ .../x86/intel-speed-select/isst-display.c     | 11 ++++
+ tools/power/x86/intel-speed-select/isst.h     |  6 ++
+ 3 files changed, 72 insertions(+)
+
+diff --git a/tools/power/x86/intel-speed-select/isst-core.c b/tools/power/x86/intel-speed-select/isst-core.c
+index d14c7bcd327a..81a119f688a3 100644
+--- a/tools/power/x86/intel-speed-select/isst-core.c
++++ b/tools/power/x86/intel-speed-select/isst-core.c
+@@ -6,6 +6,44 @@
+
+ #include "isst.h"
+
++int isst_write_pm_config(int cpu, int cp_state)
++{
++	unsigned int req, resp;
++	int ret;
++
++	if (cp_state)
++		req = BIT(16);
++	else
++		req = 0;
++
++	ret = isst_send_mbox_command(cpu, WRITE_PM_CONFIG, PM_FEATURE, 0, req,
++				     &resp);
++	if (ret)
++		return ret;
++
++	debug_printf("cpu:%d WRITE_PM_CONFIG resp:%x\n", cpu, resp);
++
++	return 0;
++}
++
++int isst_read_pm_config(int cpu, int *cp_state, int *cp_cap)
++{
++	unsigned int resp;
++	int ret;
++
++	ret = isst_send_mbox_command(cpu, READ_PM_CONFIG, PM_FEATURE, 0, 0,
++				     &resp);
++	if (ret)
++		return ret;
++
++	debug_printf("cpu:%d READ_PM_CONFIG resp:%x\n", cpu, resp);
++
++	*cp_state = resp & BIT(16);
++	*cp_cap = resp & BIT(0) ? 1 : 0;
++
++	return 0;
++}
++
+ int isst_get_ctdp_levels(int cpu, struct isst_pkg_ctdp *pkg_dev)
+ {
+ 	unsigned int resp;
+@@ -36,6 +74,7 @@ int isst_get_ctdp_levels(int cpu, struct isst_pkg_ctdp *pkg_dev)
+ int isst_get_ctdp_control(int cpu, int config_index,
+ 			  struct isst_pkg_ctdp_level_info *ctdp_level)
+ {
++	int cp_state, cp_cap;
+ 	unsigned int resp;
+ 	int ret;
+
+@@ -50,6 +89,15 @@ int isst_get_ctdp_control(int cpu, int config_index,
+ 	ctdp_level->fact_enabled = !!(resp & BIT(16));
+ 	ctdp_level->pbf_enabled = !!(resp & BIT(17));
+
++	ret = isst_read_pm_config(cpu, &cp_state, &cp_cap);
++	if (ret) {
++		debug_printf("cpu:%d pm_config is not supported \n", cpu);
++	} else {
++		debug_printf("cpu:%d pm_config SST-CP state:%d cap:%d \n", cpu, cp_state, cp_cap);
++		ctdp_level->sst_cp_support = cp_cap;
++		ctdp_level->sst_cp_enabled = cp_state;
++	}
++
+ 	debug_printf(
+ 		"cpu:%d CONFIG_TDP_GET_TDP_CONTROL resp:%x fact_support:%d pbf_support: %d fact_enabled:%d pbf_enabled:%d\n",
+ 		cpu, resp, ctdp_level->fact_support, ctdp_level->pbf_support,
+@@ -779,6 +827,13 @@ int isst_pm_qos_config(int cpu, int enable_clos, int priority_type)
+ 			debug_printf("Turbo-freq feature must be disabled first\n");
+ 			return -EINVAL;
+ 		}
++		ret = isst_write_pm_config(cpu, 0);
++		if (ret)
++			perror("isst_write_pm_config\n");
++	} else {
++		ret = isst_write_pm_config(cpu, 1);
++		if (ret)
++			perror("isst_write_pm_config\n");
+ 	}
+
+ 	ret = isst_send_mbox_command(cpu, CONFIG_CLOS, CLOS_PM_QOS_CONFIG, 0, 0,
+diff --git a/tools/power/x86/intel-speed-select/isst-display.c b/tools/power/x86/intel-speed-select/isst-display.c
+index 040dd09d5eee..1d1439036c12 100644
+--- a/tools/power/x86/intel-speed-select/isst-display.c
++++ b/tools/power/x86/intel-speed-select/isst-display.c
+@@ -418,6 +418,17 @@ void isst_ctdp_display_information(int cpu, FILE *outf, int tdp_level,
+ 			snprintf(value, sizeof(value), "unsupported");
+ 		format_and_print(outf, base_level + 4, header, value);
+
++		snprintf(header, sizeof(header),
++			 "speed-select-core-power");
++		if (ctdp_level->sst_cp_support) {
++			if (ctdp_level->sst_cp_enabled)
++				snprintf(value, sizeof(value), "enabled");
++			else
++				snprintf(value, sizeof(value), "disabled");
++		} else
++			snprintf(value, sizeof(value), "unsupported");
++		format_and_print(outf, base_level + 4, header, value);
++
+ 		if (is_clx_n_platform()) {
+ 			if (ctdp_level->pbf_support)
+ 				_isst_pbf_display_information(cpu, outf,
+diff --git a/tools/power/x86/intel-speed-select/isst.h b/tools/power/x86/intel-speed-select/isst.h
+index cdf0f8a6dbbf..ad5aa6341d0f 100644
+--- a/tools/power/x86/intel-speed-select/isst.h
++++ b/tools/power/x86/intel-speed-select/isst.h
+@@ -69,6 +69,10 @@
+ #define PM_CLOS_OFFSET				0x08
+ #define PQR_ASSOC_OFFSET			0x20
+
++#define READ_PM_CONFIG				0x94
++#define WRITE_PM_CONFIG				0x95
++#define PM_FEATURE				0x03
++
+ #define DISP_FREQ_MULTIPLIER 100
+
+ struct isst_clos_config {
+@@ -119,6 +123,8 @@ struct isst_pkg_ctdp_level_info {
+ 	int pbf_support;
+ 	int fact_enabled;
+ 	int pbf_enabled;
++	int sst_cp_support;
++	int sst_cp_enabled;
+ 	int tdp_ratio;
+ 	int active;
+ 	int tdp_control;
+--
+2.24.1
diff --git a/isst_03.patch b/isst_03.patch
new file mode 100644
index 0000000..ad5225d
--- /dev/null
+++ b/isst_03.patch
@@ -0,0 +1,93 @@
+From: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+To: andriy.shevchenko@intel.com, prarit@redhat.com
+Cc: platform-driver-x86@vger.kernel.org,
+	linux-kernel@vger.kernel.org,
+	Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+Subject: [PATCH 3/5] tools/power/x86/intel-speed-select: Fix result display for turbo-freq auto mode
+Date: Tue, 14 Jan 2020 11:22:15 -0800
+Message-ID: <20200114192217.580364-4-srinivas.pandruvada@linux.intel.com> (raw)
+In-Reply-To: <20200114192217.580364-1-srinivas.pandruvada@linux.intel.com>
+
+The turbo-freq enable with auto mode, prints result for the last possible
+CPU, which is not correct when either CPU is not present or user wants
+command to be limited to a single die/package. For example, in the
+below command user wants to limit to die/package 0, but the
+"turbo-freq --auto" result is displayed using the other package.
+
+$ sudo intel-speed-select -c 0 turbo-freq enable -a
+Intel(R) Speed Select Technology
+ package-0
+  die-0
+    cpu-0
+      turbo-freq
+        enable:success
+ package--1
+  die-0
+    cpu-31
+      turbo-freq --auto
+        enable:success
+
+Since we do have to traverse all CPUs, don't display CPU info for
+"turbo-freq --auto", as we already displayed the result for
+turbo-freq enable with the CPU information.
+
+With the fix, the same command results in:
+
+$ sudo intel-speed-select -c 0 turbo-freq enable -a
+Intel(R) Speed Select Technology
+package-0
+  die-0
+    cpu-0
+      turbo-freq
+        enable:success
+      turbo-freq --auto
+        enable:success
+
+Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+---
+ tools/power/x86/intel-speed-select/isst-config.c |  2 +-
+ .../power/x86/intel-speed-select/isst-display.c  | 16 +++++++++-------
+ 2 files changed, 10 insertions(+), 8 deletions(-)
+
+diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
+index 944183f9ed5a..e22a694e6410 100644
+--- a/tools/power/x86/intel-speed-select/isst-config.c
++++ b/tools/power/x86/intel-speed-select/isst-config.c
+@@ -1638,7 +1638,7 @@ static void set_fact_enable(int arg)
+ 			if (ret)
+ 				goto error_disp;
+ 		}
+-		isst_display_result(i, outf, "turbo-freq --auto", "enable", 0);
++		isst_display_result(-1, outf, "turbo-freq --auto", "enable", 0);
+ 	}
+
+ 	return;
+diff --git a/tools/power/x86/intel-speed-select/isst-display.c b/tools/power/x86/intel-speed-select/isst-display.c
+index 1d1439036c12..4fb0c1d49d64 100644
+--- a/tools/power/x86/intel-speed-select/isst-display.c
++++ b/tools/power/x86/intel-speed-select/isst-display.c
+@@ -645,13 +645,15 @@ void isst_display_result(int cpu, FILE *outf, char *feature, char *cmd,
+ 	char header[256];
+ 	char value[256];
+
+-	snprintf(header, sizeof(header), "package-%d",
+-		 get_physical_package_id(cpu));
+-	format_and_print(outf, 1, header, NULL);
+-	snprintf(header, sizeof(header), "die-%d", get_physical_die_id(cpu));
+-	format_and_print(outf, 2, header, NULL);
+-	snprintf(header, sizeof(header), "cpu-%d", cpu);
+-	format_and_print(outf, 3, header, NULL);
++	if (cpu >= 0) {
++		snprintf(header, sizeof(header), "package-%d",
++			 get_physical_package_id(cpu));
++		format_and_print(outf, 1, header, NULL);
++		snprintf(header, sizeof(header), "die-%d", get_physical_die_id(cpu));
++		format_and_print(outf, 2, header, NULL);
++		snprintf(header, sizeof(header), "cpu-%d", cpu);
++		format_and_print(outf, 3, header, NULL);
++	}
+ 	snprintf(header, sizeof(header), "%s", feature);
+ 	format_and_print(outf, 4, header, NULL);
+ 	snprintf(header, sizeof(header), "%s", cmd);
+--
+2.24.1
diff --git a/isst_04.patch b/isst_04.patch
new file mode 100644
index 0000000..7807aba
--- /dev/null
+++ b/isst_04.patch
@@ -0,0 +1,82 @@
+From: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+To: andriy.shevchenko@intel.com, prarit@redhat.com
+Cc: platform-driver-x86@vger.kernel.org,
+	linux-kernel@vger.kernel.org,
+	Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+Subject: [PATCH 4/5] tools/power/x86/intel-speed-select: Change the order for clos disable
+Date: Tue, 14 Jan 2020 11:22:16 -0800
+Message-ID: <20200114192217.580364-5-srinivas.pandruvada@linux.intel.com> (raw)
+In-Reply-To: <20200114192217.580364-1-srinivas.pandruvada@linux.intel.com>
+
+In turbo-freq or base-freq auto mode, for disable, first disable the feature and
+then disable clos.
+
+Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+---
+ .../x86/intel-speed-select/isst-config.c      | 30 +++++++++----------
+ 1 file changed, 14 insertions(+), 16 deletions(-)
+
+diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
+index e22a694e6410..84baba34d311 100644
+--- a/tools/power/x86/intel-speed-select/isst-config.c
++++ b/tools/power/x86/intel-speed-select/isst-config.c
+@@ -1384,14 +1384,10 @@ static void set_pbf_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
+ 		goto disp_result;
+ 	}
+
+-	if (auto_mode) {
+-		if (status) {
+-			ret = set_pbf_core_power(cpu);
+-			if (ret)
+-				goto disp_result;
+-		} else {
+-			isst_pm_qos_config(cpu, 0, 0);
+-		}
++	if (auto_mode && status) {
++		ret = set_pbf_core_power(cpu);
++		if (ret)
++			goto disp_result;
+ 	}
+
+ 	ret = isst_set_pbf_fact_status(cpu, 1, status);
+@@ -1408,6 +1404,9 @@ static void set_pbf_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
+ 		}
+ 	}
+
++	if (auto_mode && !status)
++		isst_pm_qos_config(cpu, 0, 0);
++
+ disp_result:
+ 	if (status)
+ 		isst_display_result(cpu, outf, "base-freq", "enable",
+@@ -1496,14 +1495,10 @@ static void set_fact_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
+ 	int ret;
+ 	int status = *(int *)arg4;
+
+-	if (auto_mode) {
+-		if (status) {
+-			ret = isst_pm_qos_config(cpu, 1, 1);
+-			if (ret)
+-				goto disp_results;
+-		} else {
+-			isst_pm_qos_config(cpu, 0, 0);
+-		}
++	if (auto_mode && status) {
++		ret = isst_pm_qos_config(cpu, 1, 1);
++		if (ret)
++			goto disp_results;
+ 	}
+
+ 	ret = isst_set_pbf_fact_status(cpu, 0, status);
+@@ -1524,6 +1519,9 @@ static void set_fact_for_cpu(int cpu, void *arg1, void *arg2, void *arg3,
+ 			ret = isst_set_trl(cpu, fact_trl);
+ 		if (ret && auto_mode)
+ 			isst_pm_qos_config(cpu, 0, 0);
++	} else {
++		if (auto_mode)
++			isst_pm_qos_config(cpu, 0, 0);
+ 	}
+
+ disp_results:
+--
+2.24.1
diff --git a/isst_05.patch b/isst_05.patch
new file mode 100644
index 0000000..cef433c
--- /dev/null
+++ b/isst_05.patch
@@ -0,0 +1,32 @@
+From: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+To: andriy.shevchenko@intel.com, prarit@redhat.com
+Cc: platform-driver-x86@vger.kernel.org,
+	linux-kernel@vger.kernel.org,
+	Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+Subject: [PATCH 5/5] tools/power/x86/intel-speed-select: Update version
+Date: Tue, 14 Jan 2020 11:22:17 -0800
+Message-ID: <20200114192217.580364-6-srinivas.pandruvada@linux.intel.com> (raw)
+In-Reply-To: <20200114192217.580364-1-srinivas.pandruvada@linux.intel.com>
+
+As we added new set of mailbox commands, increment version.
+
+Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+---
+ tools/power/x86/intel-speed-select/isst-config.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/tools/power/x86/intel-speed-select/isst-config.c b/tools/power/x86/intel-speed-select/isst-config.c
+index 84baba34d311..2b2b8167c65b 100644
+--- a/tools/power/x86/intel-speed-select/isst-config.c
++++ b/tools/power/x86/intel-speed-select/isst-config.c
+@@ -15,7 +15,7 @@ struct process_cmd_struct {
+ 	int arg;
+ };
+
+-static const char *version_str = "v1.1";
++static const char *version_str = "v1.2";
+ static const int supported_api_ver = 1;
+ static struct isst_if_platform_info isst_platform_info;
+ static char *progname;
+--
+2.24.1
diff --git a/mmgupta.patch b/mmgupta.patch
new file mode 100644
index 0000000..18ba3e0
--- /dev/null
+++ b/mmgupta.patch
@@ -0,0 +1,463 @@
+For some applications we need to allocate almost all memory as
+hugepages. However, on a running system, higher order allocations can
+fail if the memory is fragmented. Linux kernel currently does on-demand
+compaction as we request more hugepages but this style of compaction
+incurs very high latency. Experiments with one-time full memory
+compaction (followed by hugepage allocations) shows that kernel is able
+to restore a highly fragmented memory state to a fairly compacted memory
+state within <1 sec for a 32G system. Such data suggests that a more
+proactive compaction can help us allocate a large fraction of memory as
+hugepages keeping allocation latencies low.
+
+For a more proactive compaction, the approach taken here is to define
+per page-node tunable called ‘hpage_compaction_effort’ which dictates
+bounds for external fragmentation for HPAGE_PMD_ORDER pages which
+kcompactd should try to maintain.
+
+The tunable is exposed through sysfs:
+  /sys/kernel/mm/compaction/node-n/hpage_compaction_effort
+
+The value of this tunable is used to determine low and high thresholds
+for external fragmentation wrt HPAGE_PMD_ORDER order.
+
+Note that previous version of this patch [1] was found to introduce too
+many tunables (per-order, extfrag_{low, high}) but this one reduces them
+to just (per-node, hpage_compaction_effort). Also, the new tunable is an
+opaque value instead of asking for specific bounds of “external
+fragmentation” which would have been difficult to estimate. The internal
+interpretation of this opaque value allows for future fine-tuning.
+
+Currently, we use a simple translation from this tunable to [low, high]
+extfrag thresholds (low=100-hpage_compaction_effort, high=low+10%). To
+periodically check per-node extfrag status, we reuse per-node kcompactd
+threads which are woken up every few milliseconds to check the same. If
+any zone on its corresponding node has extfrag above the high threshold
+for the HPAGE_PMD_ORDER order, the thread starts compaction in
+background till all zones are below the low extfrag level for this
+order. By default. By default, the tunable is set to 0 (=> low=100%,
+high=100%).
+
+This patch is largely based on ideas from Michal Hocko posted here:
+https://lore.kernel.org/linux-mm/20161230131412.GI13301@dhcp22.suse.cz/
+
+* Performance data
+
+System: x64_64, 32G RAM, 12-cores.
+
+I made a small driver that allocates as many hugepages as possible and
+measures allocation latency:
+
+The driver first tries to allocate hugepage using GFP_TRANSHUGE_LIGHT
+and if that fails, tries to allocate with `GFP_TRANSHUGE |
+__GFP_RETRY_MAYFAIL`. The drives stops when both methods fail for a
+hugepage allocation.
+
+Before starting the driver, the system was fragmented from a userspace
+program that allocates all memory and then for each 2M aligned section,
+frees 3/4 of base pages using munmap. The workload is mainly anonymous
+userspace pages which are easy to move around. I intentionally avoided
+unmovable pages in this test to see how much latency we incur just by
+hitting the slow path for most allocations.
+
+(all latency values are in microseconds)
+
+- With vanilla kernel 5.4.0-rc5:
+
+percentile latency
+---------- -------
+         5       7
+        10       7
+        25       8
+        30       8
+        40       8
+        50       8
+        60       9
+        75     215
+        80     222
+        90     323
+        95     429
+
+Total 2M hugepages allocated = 1829 (3.5G worth of hugepages out of 25G
+total free => 14% of free memory could be allocated as hugepages)
+
+- Now with kernel 5.4.0-rc5 + this patch:
+(hpage_compaction_effort = 60)
+
+percentile latency
+---------- -------
+         5       3
+        10       3
+        25       4
+        30       4
+        40       4
+        50       4
+        60       5
+        75       6
+        80       9
+        90     370
+        95     652
+
+Total 2M hugepages allocated = 11120 (21.7G worth of hugepages out of
+25G total free => 86% of free memory could be allocated as hugepages)
+
+Above workload produces a memory state which is easy to compact.
+However, if memory is filled with unmovable pages, pro-active compaction
+should essentially back off. To test this aspect, I ran a mix of this
+workload (thanks to Matthew Wilcox for suggesting these):
+
+- dentry_thrash: it opens /tmp/missing.x for x in [1, 1000000] where
+first 10000 files actually exist.
+- pagecache_thrash: it opens a 128G file (on a 32G system) and then
+reads at random offsets.
+
+With this mix of workload, system quickly reaches 90-100% fragmentation
+wrt order-9. Trace of compaction events shows that we keep hitting
+compaction_deferred event, as expected.
+
+After terminating dentry_thrash and dropping denty caches, the system
+could proceed with compaction according to set value of
+hpage_compaction_effort (60).
+
+[1] https://patchwork.kernel.org/patch/11098289/
+
+Signed-off-by: Nitin Gupta <nigupta@nvidia.com>
+---
+ include/linux/compaction.h |  10 ++
+ mm/compaction.c            | 193 ++++++++++++++++++++++++++++++-------
+ mm/vmstat.c                |  12 +++
+ 3 files changed, 178 insertions(+), 37 deletions(-)
+
+diff --git a/include/linux/compaction.h b/include/linux/compaction.h
+index 4b898cdbdf05..7bf78b74b46a 100644
+--- a/include/linux/compaction.h
++++ b/include/linux/compaction.h
+@@ -60,6 +60,15 @@ enum compact_result {
+ 
+ struct alloc_context; /* in mm/internal.h */
+ 
++// "node-%d"
++#define COMPACTION_STATE_NAME_LEN 16
++// Per-node compaction state
++struct compaction_state {
++	int node_id;
++	unsigned int hpage_compaction_effort;
++	char name[COMPACTION_STATE_NAME_LEN];
++};
++
+ /*
+  * Number of free order-0 pages that should be available above given watermark
+  * to make sure compaction has reasonable chance of not running out of free
+@@ -90,6 +99,7 @@ extern int sysctl_compaction_handler(struct ctl_table *table, int write,
+ extern int sysctl_extfrag_threshold;
+ extern int sysctl_compact_unevictable_allowed;
+ 
++extern int extfrag_for_order(struct zone *zone, unsigned int order);
+ extern int fragmentation_index(struct zone *zone, unsigned int order);
+ extern enum compact_result try_to_compact_pages(gfp_t gfp_mask,
+ 		unsigned int order, unsigned int alloc_flags,
+diff --git a/mm/compaction.c b/mm/compaction.c
+index 672d3c78c6ab..2b933e9baa3e 100644
+--- a/mm/compaction.c
++++ b/mm/compaction.c
+@@ -25,6 +25,10 @@
+ #include <linux/psi.h>
+ #include "internal.h"
+ 
++#ifdef CONFIG_COMPACTION
++static struct compaction_state compaction_states[MAX_NUMNODES];
++#endif
++
+ #ifdef CONFIG_COMPACTION
+ static inline void count_compact_event(enum vm_event_item item)
+ {
+@@ -1846,6 +1850,31 @@ static inline bool is_via_compact_memory(int order)
+ 	return order == -1;
+ }
+ 
++static unsigned int extfrag_hpage_wmark(struct zone *zone, bool low)
++{
++	int node_id, wmark, wmark_low;
++
++	node_id = zone->zone_pgdat->node_id;
++	wmark_low = 100 - compaction_states[node_id].hpage_compaction_effort;
++	wmark = low ? wmark_low : min(wmark_low + 10, 100);
++
++	return extfrag_for_order(zone, HUGETLB_PAGE_ORDER) > wmark;
++}
++
++static bool node_hpage_should_compact(pg_data_t *pgdat)
++{
++	struct zone *zone;
++
++	for_each_populated_zone(zone) {
++		if (extfrag_hpage_wmark(zone, false) &&
++			compaction_suitable(zone, HUGETLB_PAGE_ORDER,
++				0, zone_idx(zone)) == COMPACT_CONTINUE) {
++			return true;
++		}
++	}
++	return false;
++}
++
+ static enum compact_result __compact_finished(struct compact_control *cc)
+ {
+ 	unsigned int order;
+@@ -1875,6 +1904,9 @@ static enum compact_result __compact_finished(struct compact_control *cc)
+ 	if (is_via_compact_memory(cc->order))
+ 		return COMPACT_CONTINUE;
+ 
++	if (extfrag_hpage_wmark(cc->zone, true))
++		return COMPACT_CONTINUE;
++
+ 	/*
+ 	 * Always finish scanning a pageblock to reduce the possibility of
+ 	 * fallbacks in the future. This is particularly important when
+@@ -1965,15 +1997,6 @@ static enum compact_result __compaction_suitable(struct zone *zone, int order,
+ 	if (is_via_compact_memory(order))
+ 		return COMPACT_CONTINUE;
+ 
+-	watermark = wmark_pages(zone, alloc_flags & ALLOC_WMARK_MASK);
+-	/*
+-	 * If watermarks for high-order allocation are already met, there
+-	 * should be no need for compaction at all.
+-	 */
+-	if (zone_watermark_ok(zone, order, watermark, classzone_idx,
+-								alloc_flags))
+-		return COMPACT_SUCCESS;
+-
+ 	/*
+ 	 * Watermarks for order-0 must be met for compaction to be able to
+ 	 * isolate free pages for migration targets. This means that the
+@@ -2003,31 +2026,9 @@ enum compact_result compaction_suitable(struct zone *zone, int order,
+ 					int classzone_idx)
+ {
+ 	enum compact_result ret;
+-	int fragindex;
+ 
+ 	ret = __compaction_suitable(zone, order, alloc_flags, classzone_idx,
+ 				    zone_page_state(zone, NR_FREE_PAGES));
+-	/*
+-	 * fragmentation index determines if allocation failures are due to
+-	 * low memory or external fragmentation
+-	 *
+-	 * index of -1000 would imply allocations might succeed depending on
+-	 * watermarks, but we already failed the high-order watermark check
+-	 * index towards 0 implies failure is due to lack of memory
+-	 * index towards 1000 implies failure is due to fragmentation
+-	 *
+-	 * Only compact if a failure would be due to fragmentation. Also
+-	 * ignore fragindex for non-costly orders where the alternative to
+-	 * a successful reclaim/compaction is OOM. Fragindex and the
+-	 * vm.extfrag_threshold sysctl is meant as a heuristic to prevent
+-	 * excessive compaction for costly orders, but it should not be at the
+-	 * expense of system stability.
+-	 */
+-	if (ret == COMPACT_CONTINUE && (order > PAGE_ALLOC_COSTLY_ORDER)) {
+-		fragindex = fragmentation_index(zone, order);
+-		if (fragindex >= 0 && fragindex <= sysctl_extfrag_threshold)
+-			ret = COMPACT_NOT_SUITABLE_ZONE;
+-	}
+ 
+ 	trace_mm_compaction_suitable(zone, order, ret);
+ 	if (ret == COMPACT_NOT_SUITABLE_ZONE)
+@@ -2419,7 +2420,6 @@ static void compact_node(int nid)
+ 		.gfp_mask = GFP_KERNEL,
+ 	};
+ 
+-
+ 	for (zoneid = 0; zoneid < MAX_NR_ZONES; zoneid++) {
+ 
+ 		zone = &pgdat->node_zones[zoneid];
+@@ -2492,8 +2492,122 @@ void compaction_unregister_node(struct node *node)
+ }
+ #endif /* CONFIG_SYSFS && CONFIG_NUMA */
+ 
++#ifdef CONFIG_SYSFS
++
++#define COMPACTION_ATTR_RO(_name) \
++	static struct kobj_attribute _name##_attr = __ATTR_RO(_name)
++
++#define COMPACTION_ATTR(_name) \
++	static struct kobj_attribute _name##_attr = \
++		__ATTR(_name, 0644, _name##_show, _name##_store)
++
++static struct kobject *compaction_kobj;
++static struct kobject *compaction_kobjs[MAX_NUMNODES];
++
++static struct compaction_state *kobj_to_compaction_state(struct kobject *kobj)
++{
++	int node;
++
++	for_each_online_node(node) {
++		if (compaction_kobjs[node] == kobj)
++			return &compaction_states[node];
++	}
++
++	return NULL;
++}
++
++static ssize_t hpage_compaction_effort_store(struct kobject *kobj,
++		struct kobj_attribute *attr, const char *buf, size_t count)
++{
++	int err;
++	unsigned long input;
++	struct compaction_state *c = kobj_to_compaction_state(kobj);
++
++	err = kstrtoul(buf, 10, &input);
++	if (err)
++		return err;
++	if (input > 100)
++		return -EINVAL;
++
++	c->hpage_compaction_effort = input;
++	return count;
++}
++
++static ssize_t hpage_compaction_effort_show(struct kobject *kobj,
++		struct kobj_attribute *attr, char *buf)
++{
++	struct compaction_state *c = kobj_to_compaction_state(kobj);
++
++	return sprintf(buf, "%u\n", c->hpage_compaction_effort);
++}
++
++COMPACTION_ATTR(hpage_compaction_effort);
++
++static struct attribute *compaction_attrs[] = {
++	&hpage_compaction_effort_attr.attr,
++	NULL,
++};
++
++static const struct attribute_group compaction_attr_group = {
++	.attrs = compaction_attrs,
++};
++
++static int compaction_sysfs_add_node(struct compaction_state *c,
++	struct kobject *parent, struct kobject **compaction_kobjs,
++	const struct attribute_group *compaction_attr_group)
++{
++	int retval;
++
++	compaction_kobjs[c->node_id] =
++			kobject_create_and_add(c->name, parent);
++	if (!compaction_kobjs[c->node_id])
++		return -ENOMEM;
++
++	retval = sysfs_create_group(compaction_kobjs[c->node_id],
++				compaction_attr_group);
++	if (retval)
++		kobject_put(compaction_kobjs[c->node_id]);
++
++	return retval;
++}
++
++static void __init compaction_sysfs_init(void)
++{
++	struct compaction_state *c;
++	int err, node;
++
++	compaction_kobj = kobject_create_and_add("compaction", mm_kobj);
++	if (!compaction_kobj)
++		return;
++
++	for_each_online_node(node) {
++		c = &compaction_states[node];
++		err = compaction_sysfs_add_node(c, compaction_kobj,
++					compaction_kobjs,
++					&compaction_attr_group);
++		if (err)
++			pr_err("compaction: Unable to add state %s", c->name);
++	}
++}
++
++static void __init compaction_init(void)
++{
++	int node;
++
++	for_each_online_node(node) {
++		struct compaction_state *c = &compaction_states[node];
++
++		c->node_id = node;
++		c->hpage_compaction_effort = 0;
++		snprintf(c->name, COMPACTION_STATE_NAME_LEN, "node-%d", node);
++	}
++}
++#endif
++
+ static inline bool kcompactd_work_requested(pg_data_t *pgdat)
+ {
++	if (node_hpage_should_compact(pgdat) && !pgdat->kcompactd_max_order)
++		pgdat->kcompactd_max_order = 1;
+ 	return pgdat->kcompactd_max_order > 0 || kthread_should_stop();
+ }
+ 
+@@ -2529,7 +2643,7 @@ static void kcompactd_do_work(pg_data_t *pgdat)
+ 		.order = pgdat->kcompactd_max_order,
+ 		.search_order = pgdat->kcompactd_max_order,
+ 		.classzone_idx = pgdat->kcompactd_classzone_idx,
+-		.mode = MIGRATE_SYNC_LIGHT,
++		.mode = MIGRATE_SYNC,
+ 		.ignore_skip_hint = false,
+ 		.gfp_mask = GFP_KERNEL,
+ 	};
+@@ -2556,7 +2670,6 @@ static void kcompactd_do_work(pg_data_t *pgdat)
+ 
+ 		cc.zone = zone;
+ 		status = compact_zone(&cc, NULL);
+-
+ 		if (status == COMPACT_SUCCESS) {
+ 			compaction_defer_reset(zone, cc.order, false);
+ 		} else if (status == COMPACT_PARTIAL_SKIPPED || status == COMPACT_COMPLETE) {
+@@ -2641,11 +2754,14 @@ static int kcompactd(void *p)
+ 	pgdat->kcompactd_classzone_idx = pgdat->nr_zones - 1;
+ 
+ 	while (!kthread_should_stop()) {
+-		unsigned long pflags;
++		unsigned long ret, pflags;
+ 
+ 		trace_mm_compaction_kcompactd_sleep(pgdat->node_id);
+-		wait_event_freezable(pgdat->kcompactd_wait,
+-				kcompactd_work_requested(pgdat));
++		ret = wait_event_freezable_timeout(pgdat->kcompactd_wait,
++				kcompactd_work_requested(pgdat),
++				msecs_to_jiffies(500));
++		if (!ret)
++			continue;
+ 
+ 		psi_memstall_enter(&pflags);
+ 		kcompactd_do_work(pgdat);
+@@ -2726,6 +2842,9 @@ static int __init kcompactd_init(void)
+ 		return ret;
+ 	}
+ 
++	compaction_init();
++	compaction_sysfs_init();
++
+ 	for_each_node_state(nid, N_MEMORY)
+ 		kcompactd_run(nid);
+ 	return 0;
+diff --git a/mm/vmstat.c b/mm/vmstat.c
+index a8222041bd44..0230a45c548a 100644
+--- a/mm/vmstat.c
++++ b/mm/vmstat.c
+@@ -1074,6 +1074,18 @@ static int __fragmentation_index(unsigned int order, struct contig_page_info *in
+ 	return 1000 - div_u64( (1000+(div_u64(info->free_pages * 1000ULL, requested))), info->free_blocks_total);
+ }
+ 
++int extfrag_for_order(struct zone *zone, unsigned int order)
++{
++	struct contig_page_info info;
++
++	fill_contig_page_info(zone, order, &info);
++	if (info.free_pages == 0)
++		return 0;
++
++	return (info.free_pages - (info.free_blocks_suitable << order)) * 100
++							/ info.free_pages;
++}
++
+ /* Same as __fragmentation index but allocs contig_page_info on stack */
+ int fragmentation_index(struct zone *zone, unsigned int order)
+ {
+-- 
+2.17.1
